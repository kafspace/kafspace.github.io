<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaSE（五）-集合类与IO</title>
    <link href="/2023/03/05/JavaSE%20%EF%BC%88%E4%BA%94%EF%BC%89-%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8EIO/"/>
    <url>/2023/03/05/JavaSE%20%EF%BC%88%E4%BA%94%EF%BC%89-%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8EIO/</url>
    
    <content type="html"><![CDATA[<h1 id="集合类与IO"><a href="#集合类与IO" class="headerlink" title="集合类与IO"></a>集合类与IO</h1><span id="more"></span><h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p>集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。</p><p>集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（先从接口定义对于集合需要实现哪些功能开始说起，包括这些集合类的底层机制是如何运作的）不仅仅是教会大家如何去使用。</p><p>集合跟数组一样，可以表示同样的一组元素，但是他们的相同和不同之处在于：</p><ol><li>它们都是容器，都能够容纳一组元素。</li></ol><p>不同之处：</p><ol><li>数组的大小是固定的，集合的大小是可变的。</li><li>数组可以存放基本数据类型，但集合只能存放对象。</li><li>数组存放的类型只能是一种，但集合可以有不同种类的元素</li></ol><h3 id="集合根接口"><a href="#集合根接口" class="headerlink" title="集合根接口"></a>集合根接口</h3><p>Java中已经将常用的集合类型都实现好了，只需要直接拿来用就行了，比如之前学习的顺序表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;   <span class="hljs-comment">//集合类基本都是在java.util包下定义的</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;树脂666&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所有的集合类最终都是实现自集合根接口的，比如ArrayList类，它的祖先就是Collection接口：</p><p><img src="/../img/images/U9DdJinhCp6BITe.png"></p><p>这个接口定义了集合类的一些基本操作，来看看有哪些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterable</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//-------这些是查询相关的操作----------</span><br><br>       <span class="hljs-comment">//获取当前集合中的元素数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//查看当前集合是否为空</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//查询当前集合中是否包含某个元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-comment">//返回当前集合的迭代器，我们会在后面介绍</span><br>    Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//将集合转换为数组的形式</span><br>    Object[] toArray();<br><br>    <span class="hljs-comment">//支持泛型的数组转换，同上</span><br>    &lt;T&gt; T[] toArray(T[] a);<br><br>    <span class="hljs-comment">//-------这些是修改相关的操作----------</span><br><br>    <span class="hljs-comment">//向集合中添加元素，不同的集合类具体实现可能会对插入的元素有要求，</span><br>      <span class="hljs-comment">//这个操作并不是一定会添加成功，所以添加成功返回true，否则返回false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//从集合中移除某个元素，同样的，移除成功返回true，否则false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br><br><br>    <span class="hljs-comment">//-------这些是批量执行的操作----------</span><br><br>    <span class="hljs-comment">//查询当前集合是否包含给定集合中所有的元素</span><br>      <span class="hljs-comment">//从数学角度来说，就是看给定集合是不是当前集合的子集</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-comment">//添加给定集合中所有的元素</span><br>      <span class="hljs-comment">//从数学角度来说，就是将当前集合变成当前集合与给定集合的并集</span><br>      <span class="hljs-comment">//添加成功返回true，否则返回false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span>;<br><br>    <span class="hljs-comment">//移除给定集合中出现的所有元素，如果某个元素在当前集合中不存在，那么忽略这个元素</span><br>      <span class="hljs-comment">//从数学角度来说，就是求当前集合与给定集合的差集</span><br>      <span class="hljs-comment">//移除成功返回true，否则false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-comment">//Java8新增方法，根据给定的Predicate条件进行元素移除操作</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> E&gt; filter)</span> &#123;<br>        Objects.requireNonNull(filter);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> Iterator&lt;E&gt; each = iterator();   <span class="hljs-comment">//这里用到了迭代器，我们会在后面进行介绍</span><br>        <span class="hljs-keyword">while</span> (each.hasNext()) &#123;<br>            <span class="hljs-keyword">if</span> (filter.test(each.next())) &#123;<br>                each.remove();<br>                removed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> removed;<br>    &#125;<br><br>    <span class="hljs-comment">//只保留当前集合中在给定集合中出现的元素，其他元素一律移除</span><br>      <span class="hljs-comment">//从数学角度来说，就是求当前集合与给定集合的交集</span><br>      <span class="hljs-comment">//移除成功返回true，否则false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-comment">//清空整个集合，删除所有元素</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">//-------这些是比较以及哈希计算相关的操作----------</span><br><br>    <span class="hljs-comment">//判断两个集合是否相等</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-comment">//计算当前整个集合对象的哈希值</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//与迭代器作用相同，但是是并行执行的，我们会在下一章多线程部分中进行介绍</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;E&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliterator(<span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//生成当前集合的流，我们会在后面进行讲解</span><br>    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//生成当前集合的并行流，我们会在下一章多线程部分中进行介绍</span><br>    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">parallelStream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在这个接口中对于集合相关的操作，还是比较齐全的，那么我们接着就来看看它的实现类。</p><h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><p>首先我们需要介绍的是List列表（线性表），线性表支持随机访问，相比之前的Collection接口定义，功能还会更多一些。首先介绍ArrayList，我们已经知道，它的底层是用数组实现的，内部维护的是一个可动态进行扩容的数组，也就是我们之前所说的顺序表，跟我们之前自己写的ArrayList相比，它更加的规范，并且功能更加强大，同时实现自List接口。</p><p>List是集合类型的一个分支，它的主要特性有：</p><ul><li>是一个有序的集合，插入元素默认是插入到尾部，按顺序从前往后存放，每个元素都有一个自己的下标位置</li><li>列表中允许存在重复元素</li></ul><p>在List接口中，定义了列表类型需要支持的全部操作，List直接继承自前面介绍的Collection接口，其中很多地方重新定义了一次Collection接口中定义的方法，这样做是为了更加明确方法的具体功能，当然，为了直观，我们这里就省略掉：</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE（四）-泛型程序设计</title>
    <link href="/2023/03/04/JavaSE%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/03/04/JavaSE%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h1><span id="more"></span><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以<code>优秀、良好、合格</code> 来作为结果，还有一种就是 <code>60.0、75.5、92.5</code> 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个Score类呢？</p><p>现在的问题就是，成绩可能是<code>String</code>类型，也可能是<code>Integer</code>类型，如何才能很好的去存可能出现的两种类型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span> &#123;<br>    String name;<br>    String id;<br>    Object value;  <span class="hljs-comment">//因为Object是所有类型的父类，因此既可以存放Integer也能存放String</span><br><br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">Score</span><span class="hljs-params">(String name, String id, Object value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.score = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">Score</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Score</span>(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-string">&quot;优秀&quot;</span>);  <span class="hljs-comment">//是String类型的</span><br><br>    ...<br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> (Integer) score.score;  <span class="hljs-comment">//获取成绩需要进行强制类型转换，</span><br></code></pre></td></tr></table></figure><p>使用Object类型作为引用，对于使用者来说，由于是Object类型，所以说并不能直接判断存储的类型到底是String还是Integer，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺</p><p>所以说这种解决办法虽然可行，但并不是最好的方案。</p><p>为了解决以上问题，JDK 5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效率。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型。</p><p>我们可以将一个类定义为一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span>&lt;T&gt; &#123;   <span class="hljs-comment">//泛型类需要使用&lt;&gt;，我们需要在里面添加1 - N个类型变量</span><br>    String name;<br>    String id;<br>    T value;   <span class="hljs-comment">//T会根据使用时提供的类型自动变成对应类型</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Score</span><span class="hljs-params">(String name, String id, T value)</span> &#123;   <span class="hljs-comment">//这里T可以是任何类型，但是一旦确定，那么就不能修改了</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看这是如何使用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Score&lt;String&gt; score = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Score</span>&lt;String&gt;(<span class="hljs-string">&quot;计算机网络&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-string">&quot;优秀&quot;</span>);<br>      <span class="hljs-comment">//因为现在有了类型变量，在使用时同样需要跟上&lt;&gt;并在其中填写明确要使用的类型</span><br>      <span class="hljs-comment">//这样我们就可以根据不同的类型进行选择了</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> score.value;   <span class="hljs-comment">//一旦类型明确，那么泛型就变成对应的类型了</span><br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译！因为是具体使用对象时才会明确具体类型，所以说静态方法中是不能用的：</p><p><img src="/../img/images/image-20230718225701998.png"></p><p>只不过这里需要注意一下，我们在方法中使用待确定类型的变量时，因为此时并不明确具体是什么类型，那么默认会认为这个变量是一个Object类型的变量，因为无论具体类型是什么，一定是Object类的子类：</p><p><img src="/../img/images/image-20230718225624082.png"></p><p>我们可以对其进行强制类型转换，但是实际上没多大必要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) t;   <span class="hljs-comment">//都明确要用String了，那这里定义泛型不是多此一举吗</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为泛型本身就是对某些待定类型的简单处理，如果都明确要使用什么类型了，那大可不必使用泛型。还有，不能通过这个不确定的类型变量就去直接创建对象和对应的数组：</p><p><img src="/../img/images/image-20230719015637127.png"></p><p>注意，具体类型不同的泛型类变量，不能使用不同的变量进行接收：</p><p><img src="/../img/images/image-20230719015831930.png"></p><p>如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用<code>?</code>通配符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Test&lt;?&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;Integer&gt;();<br>    test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;String&gt;();<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> test.value;    <span class="hljs-comment">//但是注意，如果使用通配符，那么由于类型不确定，所以说具体类型同样会变成Object</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，泛型变量不止可以只有一个，如果需要使用多个的话，我们也可以定义多个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;A, B, C&gt; &#123;   <span class="hljs-comment">//多个类型变量使用逗号隔开</span><br>    <span class="hljs-keyword">public</span> A a;<br>    <span class="hljs-keyword">public</span> B b;<br>    <span class="hljs-keyword">public</span> C c;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么在使用时，就需要将这三种类型都进行明确指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Test&lt;String, Integer, Character&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;();  <span class="hljs-comment">//使用钻石运算符可以省略其中的类型</span><br>    test.a = <span class="hljs-string">&quot;lbwnb&quot;</span>;<br>    test.b = <span class="hljs-number">10</span>;<br>    test.c = <span class="hljs-string">&#x27;淦&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉好像还是挺简单的？只要是在类中，都可以使用类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;T&gt;&#123;<br>    <br>    <span class="hljs-keyword">private</span> T value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只不过，泛型只能确定为一个引用类型，基本类型是不支持的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">public</span> T value;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230719020112376.png"></p><p>如果要存放基本数据类型的值，只能使用对应的包装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Test&lt;Integer&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果是基本类型的数组，因为数组本身是引用类型，所以说是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Test&lt;<span class="hljs-type">int</span>[]&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用泛型，就可以将某些不明确的类型在具体使用时再明确。</p><h3 id="泛型与多态"><a href="#泛型与多态" class="headerlink" title="泛型与多态"></a>泛型与多态</h3><p>不只是类，包括接口、抽象类，都是可以支持泛型的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span>&lt;T&gt; &#123;<br>    T <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当子类实现此接口时，我们可以选择在实现类明确泛型类型，或是继续使用此泛型让具体创建的对象来确定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.test();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Study</span>&lt;Integer&gt; &#123;   <br>          <span class="hljs-comment">//在实现接口或是继承父类时，如果子类是一个普通类，那么可以直接明确对应类型</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者是依然使用泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        A&lt;String&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>&lt;&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.test();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Study</span>&lt;T&gt; &#123;   <br>          <span class="hljs-comment">//让子类继续为一个泛型类，那么可以不用明确</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继承也是同样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&lt;T&gt; &#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&lt;String&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>当然，类型变量并不是只能在泛型类中才可以使用，我们也可以定义泛型方法。</p><p>当某个方法（无论是是静态方法还是成员方法）需要接受的参数类型并不确定时，我们也可以使用泛型来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> test(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>&#123;   <span class="hljs-comment">//在返回值类型前添加&lt;&gt;并填写泛型变量表示这个是一个泛型方法</span><br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>泛型方法会在使用时自动确定泛型类型，比如上我们定义的是类型T作为参数，同样的类型T作为返回值，实际传入的参数是一个字符串类型的值，那么T就会自动变成String类型，因此返回值也是String类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    String[] strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>    main.add(strings, <span class="hljs-string">&quot;Hello&quot;</span>);<br>    System.out.println(Arrays.toString(strings));<br>&#125;<br><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T[] arr, T t)</span>&#123;<br>    arr[<span class="hljs-number">0</span>] = t;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上泛型方法在很多工具类中也有，比如说Arrays的排序方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>&#125;;<br>Arrays.sort(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;   <br>      <span class="hljs-comment">//通过创建泛型接口的匿名内部类，来自定义排序规则，因为匿名内部类就是接口的实现类，所以说这里就明确了类型</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;   <span class="hljs-comment">//这个方法会在执行排序时被调用（别人来调用我们的实现）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>比如现在我们想要让数据从大到小排列，我们就可以自定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Integer[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>&#125;;<br>    Arrays.sort(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;   <span class="hljs-comment">//两个需要比较的数会在这里给出</span><br>            <span class="hljs-keyword">return</span> o2 - o1;    <br>              <span class="hljs-comment">//compare方法要求返回一个int来表示两个数的大小关系，大于0表示大于，小于0表示小于</span><br>              <span class="hljs-comment">//这里直接o2-o1就行，如果o2比o1大，那么肯定应该排在前面，所以说返回正数表示大于</span><br>        &#125;<br>    &#125;);<br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们前面学习了Lambda表达式，像这种只有一个方法需要实现的接口，直接安排了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Integer[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>&#125;;<br>    Arrays.sort(arr, (o1, o2) -&gt; o2 - o1);   <span class="hljs-comment">//瞬间变一行，效果跟上面是一样的</span><br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p>包括数组复制方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    String[] arr = &#123;<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>&#125;;<br>    String[] newArr = Arrays.copyOf(arr, <span class="hljs-number">3</span>);   <span class="hljs-comment">//这里传入的类型是什么，返回的类型就是什么，也是用到了泛型</span><br>    System.out.println(Arrays.toString(newArr));<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计。</p><h3 id="泛型的界限"><a href="#泛型的界限" class="headerlink" title="泛型的界限"></a>泛型的界限</h3><p>现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; &#123;   <span class="hljs-comment">//设定类型参数上界，必须是Number或是Number的子类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Score</span><span class="hljs-params">(String name, String id, T value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要在泛型变量的后面添加<code>extends</code>关键字即可指定上界，使用时，具体类型只能是我们指定的上界类型或是上界类型的子类，不得是其他类型。否则一律报错：</p><p><img src="/../img/images/image-20230719022849453.png"></p><p>实际上就像这样：</p><p><img src="/../img/images/rLnjHp73tdFSPUM.png"></p><p>同样的，当我们在使用变量时，泛型通配符也支持泛型的界限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Score&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Integer</span>&gt; score = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Score</span>&lt;&gt;(<span class="hljs-string">&quot;数据结构与算法&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么既然泛型有上界，那么有没有下界呢？肯定的啊：</p><p><img src="/../img/images/image-20230719023048543.png"></p><p>只不过下界仅适用于通配符，对于类型变量来说是不支持的。下界限定就像这样：</p><p><img src="/../img/images/QFZNSCpnAmKG7qr.png"></p><p>那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Score&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; score = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Score</span>&lt;&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> score.getValue();   <span class="hljs-comment">//可以看到，此时虽然使用的是通配符，但是不再是Object类型，而是对应的上界</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是我们限定下界的话，因为还是有可能是Object，所以说依然是跟之前一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Score&lt;? <span class="hljs-built_in">super</span> Number&gt; score = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Score</span>&lt;&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> score.getValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过给设定泛型上限，我们就可以更加灵活地控制泛型的具体类型范围。</p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>前面我们已经了解如何使用泛型，那么泛型到底是如何实现的呢，程序编译之后的样子是什么样的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &lt;T&gt;&#123;<br>    <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上在Java中并不是真的有泛型类型（为了兼容之前的Java版本）因为所有的对象都是属于一个普通的类型，一个泛型类型编译之后，实际上会直接使用默认的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">test</span><span class="hljs-params">(Object t)</span>;  <span class="hljs-comment">//默认就是Object</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果我们给类型变量设定了上界，那么会从默认类型变成上界定义的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt;&#123;   <span class="hljs-comment">//设定上界为Number</span><br>    <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么编译之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">abstract</span> Number <span class="hljs-title function_">test</span><span class="hljs-params">(Number t)</span>;  <span class="hljs-comment">//上界Number，因为现在只可能出现Number的子类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因此，泛型其实仅仅是在编译阶段进行类型检查，当程序在运行时，并不会真的去检查对应类型，所以说哪怕是我们不去指定类型也可以直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();    <span class="hljs-comment">//对于泛型类Test，不指定具体类型也是可以的，默认就是原始类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只不过此时编译器会给出警告：</p><p><img src="/../img/images/image-20230719184927425.png"></p><p>同样的，由于类型擦除，实际上我们在使用时，编译后的代码是进行了强制类型转换的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    A&lt;String&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    <span class="hljs-type">String</span>  <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.test(<span class="hljs-string">&quot;10&quot;</span>);     <span class="hljs-comment">//因为类型A只有返回值为原始类型Object的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上编译之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (String) a.test(<span class="hljs-string">&quot;10&quot;</span>);   <span class="hljs-comment">//依靠强制类型转换完成的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>既然继承泛型类之后可以明确具体类型，那么为什么<code>@Override</code>不会出现错误呢？重写的条件是需要和父类的返回值类型和形参一致，而泛型默认的原始类型是Object类型，子类明确后变为其他类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&lt;String&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    String <span class="hljs-title function_">test</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看编译之后长啥样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Compiled from &quot;B.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.test.entity.B <span class="hljs-keyword">extends</span> <span class="hljs-title class_">com</span>.test.entity.A&lt;java.lang.String&gt; &#123;<br>  <span class="hljs-keyword">public</span> com.test.entity.B();<br>  java.lang.String <span class="hljs-title function_">test</span><span class="hljs-params">(java.lang.String)</span>;<br>  java.lang.Object <span class="hljs-title function_">test</span><span class="hljs-params">(java.lang.Object)</span>;   <span class="hljs-comment">//桥接方法，这才是真正重写的方法，但是使用时会调用上面的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过反编译进行观察，实际上是编译器帮助我们生成了一个桥接方法用于支持重写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">test</span><span class="hljs-params">(Object obj)</span> &#123;   <span class="hljs-comment">//这才是重写的桥接方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.test((String) obj);   <span class="hljs-comment">//桥接方法调用我们自己写的方法</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span> &#123;   <span class="hljs-comment">//我们自己写的方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类型擦除机制其实就是为了方便使用后面集合类（不然每次都要强制类型转换）同时为了向下兼容采取的方案。因此，泛型的使用会有一些限制：</p><p>首先，在进行类型判断时，不允许使用泛型，只能使用原始类型：</p><p><img src="/../img/images/image-20230719190124713.png"></p><p>只能判断是不是原始类型，里面的具体类型是不支持的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Test&lt;String&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;();<br>System.out.println(test <span class="hljs-keyword">instanceof</span> Test);   <span class="hljs-comment">//在进行类型判断时，不允许使用泛型，只能使用原始类型</span><br></code></pre></td></tr></table></figure><p>还有，泛型类型是不支持创建参数化类型数组的：</p><p><img src="/../img/images/image-20230719190251328.png"></p><p>要用只能用原始类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Test[] test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>[<span class="hljs-number">10</span>];   <span class="hljs-comment">//同样是因为类型擦除导致的，运行时可不会去检查具体类型是什么</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只不过只是把它当做泛型类型的数组还是可以用的：</p><p><img src="/../img/images/image-20230719190347391.png"></p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>学习了泛型，我们来介绍一下再JDK 1.8中新增的函数式接口。</p><p>函数式接口就是JDK1.8专门为我们提供好的用于Lambda表达式的接口，这些接口都可以直接使用Lambda表达式，非常方便，这里我们主要介绍一下四个主要的函数式接口：</p><p><strong>Supplier供给型函数式接口：</strong>这个接口是专门用于供给使用的，其中只有一个get方法用于获取需要的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>   <span class="hljs-comment">//函数式接口都会打上这样一个注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Supplier</span>&lt;T&gt; &#123;<br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//实现此方法，实现供给功能</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们要实现一个专门供给Student对象Supplier，就可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是学生！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//专门供给Student对象的Supplier</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Supplier&lt;Student&gt; STUDENT_SUPPLIER = Student::<span class="hljs-keyword">new</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> STUDENT_SUPPLIER.get();<br>    student.hello();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Consumer消费型函数式接口：</strong>这个接口专门用于消费某个对象的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span>;    <span class="hljs-comment">//这个方法就是用于消费的，没有返回值</span><br><br>    <span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; after)</span> &#123;   <span class="hljs-comment">//这个方法便于我们连续使用此消费接口</span><br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，就可以在消费之后进行一些其他的处理了，使用很简洁的代码就可以实现：</p><p><img src="/../img/images/image-20230720001656869.png"></p><p><strong>Function函数型函数式接口：</strong>这个接口消费一个对象，然后会向外供给一个对象（前两个的融合体）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Function</span>&lt;T, R&gt; &#123;<br>    R <span class="hljs-title function_">apply</span><span class="hljs-params">(T t)</span>;   <span class="hljs-comment">//这里一共有两个类型参数，其中一个是接受的参数类型，还有一个是返回的结果类型</span><br><br>    <span class="hljs-keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="hljs-title function_">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> V, ? extends T&gt; before)</span> &#123;<br>        Objects.requireNonNull(before);<br>        <span class="hljs-keyword">return</span> (V v) -&gt; apply(before.apply(v));<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> R, ? extends V&gt; after)</span> &#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; after.apply(apply(t));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Function&lt;T, T&gt; <span class="hljs-title function_">identity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t -&gt; t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口方法有点多，我们一个一个来看，首先还是最基本的<code>apply</code>方法，这个是我们需要实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里实现了一个简单的功能，将传入的int参数转换为字符串的形式</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Function&lt;Integer, String&gt; INTEGER_STRING_FUNCTION = Object::toString;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> INTEGER_STRING_FUNCTION.apply(<span class="hljs-number">10</span>);<br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用<code>compose</code>将指定函数式的结果作为当前函数式的实参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> INTEGER_STRING_FUNCTION<br>            .compose((String s) -&gt; s.length())   <span class="hljs-comment">//将此函数式的返回值作为当前实现的实参</span><br>            .apply(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//传入上面函数式需要的参数</span><br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>相反的，<code>andThen</code>可以将当前实现的返回值进行进一步的处理，得到其他类型的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> INTEGER_STRING_FUNCTION<br>            .andThen(String::isEmpty)   <span class="hljs-comment">//在执行完后，返回值作为参数执行andThen内的函数式，最后得到的结果就是最终的结果了</span><br>            .apply(<span class="hljs-number">10</span>);<br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>比较有趣的是，Function中还提供了一个将传入参数原样返回的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Function&lt;String, String&gt; function = Function.identity();   <span class="hljs-comment">//原样返回</span><br>    System.out.println(function.apply(<span class="hljs-string">&quot;不会吧不会吧，不会有人听到现在还是懵逼的吧&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Predicate断言型函数式接口：</strong>接收一个参数，然后进行自定义判断并返回一个boolean结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;    <span class="hljs-comment">//这个方法就是我们要实现的</span><br><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; other)</span> &#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">negate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (t) -&gt; !test(t);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; other)</span> &#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (t) -&gt; test(t) || other.test(t);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title function_">isEqual</span><span class="hljs-params">(Object targetRef)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-literal">null</span> == targetRef)<br>                ? Objects::isNull<br>                : object -&gt; targetRef.equals(object);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以来编写一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Predicate&lt;Student&gt; STUDENT_PREDICATE = student -&gt; student.score &gt;= <span class="hljs-number">60</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.score = <span class="hljs-number">80</span>;<br>    <span class="hljs-keyword">if</span>(STUDENT_PREDICATE.test(student)) &#123;  <span class="hljs-comment">//test方法的返回值是一个boolean结果</span><br>        System.out.println(<span class="hljs-string">&quot;及格了，真不错，今晚奖励自己一次&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不是，Java都考不及格？隔壁初中生都在打ACM了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以使用组合条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.score = <span class="hljs-number">80</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> STUDENT_PREDICATE<br>            .and(stu -&gt; stu.score &gt; <span class="hljs-number">90</span>)   <span class="hljs-comment">//需要同时满足这里的条件，才能返回true</span><br>            .test(student);<br>    <span class="hljs-keyword">if</span>(!b) System.out.println(<span class="hljs-string">&quot;Java到现在都没考到90分？你的室友都拿国家奖学金了&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，这个类型提供了一个对应的实现，用于判断两个对象是否相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Predicate&lt;String&gt; predicate = Predicate.isEqual(<span class="hljs-string">&quot;Hello World&quot;</span>);   <span class="hljs-comment">//这里传入的对象会和之后的进行比较</span><br>    System.out.println(predicate.test(<span class="hljs-string">&quot;Hello World&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用这四个核心的函数式接口，我们就可以使得代码更加简洁。</p><h3 id="判空包装"><a href="#判空包装" class="headerlink" title="判空包装"></a>判空包装</h3><p>Java8还新增了一个非常重要的判空包装类Optional，这个类可以很有效的处理空指针问题。</p><p>比如对于下面这样一个很简单的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;   <span class="hljs-comment">//传入字符串，如果不是空串，那么就打印长度</span><br>    <span class="hljs-keyword">if</span>(!str.isEmpty()) &#123;<br>        System.out.println(<span class="hljs-string">&quot;字符串长度为：&quot;</span>+str.length());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果我们在传入参数时，丢个null进去，直接原地爆炸：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    test(<span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123; <br>    <span class="hljs-keyword">if</span>(!str.isEmpty()) &#123;   <span class="hljs-comment">//此时传入的值为null，调用方法马上得到空指针异常</span><br>        System.out.println(<span class="hljs-string">&quot;字符串长度为：&quot;</span>+str.length());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们还需要在使用之前进行判空操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;<br>    <span class="hljs-keyword">if</span>(str == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//这样就可以防止null导致的异常了</span><br>    <span class="hljs-keyword">if</span>(!str.isEmpty()) &#123;<br>        System.out.println(<span class="hljs-string">&quot;字符串长度为：&quot;</span>+str.length());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这种方式很好，但是在Java8之后，有了Optional类，它可以更加优雅地处理这种问题，我们来看看如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;<br>    Optional<br>            .ofNullable(str)   <span class="hljs-comment">//将传入的对象包装进Optional中</span><br>            .ifPresent(s -&gt; System.out.println(<span class="hljs-string">&quot;字符串长度为：&quot;</span>+s.length()));  <br>                      <span class="hljs-comment">//如果不为空，则执行这里的Consumer实现</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优雅，真是太优雅了，同样的功能，现在我们只需要两行就搞定了，而且代码相当简洁。如果你学习过JavaScript或是Kotlin等语言，它的语法就像是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> str : String? = <span class="hljs-literal">null</span><br>str?.upperCase()<br></code></pre></td></tr></table></figure><p>并且，包装之后，我们再获取时可以优雅地处理为空的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Optional.ofNullable(str).get();   <span class="hljs-comment">//get方法可以获取被包装的对象引用，但是如果为空的话，会抛出异常</span><br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以对于这种有可能为空的情况进行处理，如果为空，那么就返回另一个备选方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Optional.ofNullable(str).orElse(<span class="hljs-string">&quot;我是为null的情况备选方案&quot;</span>);<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉很方便？我们还可以将包装的类型直接转换为另一种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Optional<br>            .ofNullable(str)<br>            .map(String::length)   <span class="hljs-comment">//使用map来进行映射，将当前类型转换为其他类型，或者是进行处理</span><br>            .orElse(-<span class="hljs-number">1</span>);<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE（三）-面向对象编程高级</title>
    <link href="/2023/03/03/JavaSE%EF%BC%88%E4%B8%89%EF%BC%89-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    <url>/2023/03/03/JavaSE%EF%BC%88%E4%B8%89%EF%BC%89-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象高级篇"><a href="#面向对象高级篇" class="headerlink" title="面向对象高级篇"></a>面向对象高级篇</h1><span id="more"></span><h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><h3 id="包装类介绍"><a href="#包装类介绍" class="headerlink" title="包装类介绍"></a>包装类介绍</h3><p>所有的包装类层次结构如下：</p><p><img src="/../img/images/mulb5VdvBLiWNe2.png"></p><p>其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：</p><ul><li>byte -&gt; Byte</li><li>boolean -&gt; Boolean</li><li>short -&gt; Short</li><li>char -&gt; Character</li><li>int -&gt; Integer</li><li>long -&gt; Long</li><li>float -&gt; Float</li><li>double -&gt; Double</li></ul><p>包装类实际上就是将基本数据类型，封装成一个类（运用了封装的思想）可以来看看Integer类中是怎么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value;  <span class="hljs-comment">//类中实际上就靠这个变量在存储包装的值</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Integer</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.value = value;<br>&#125;<br></code></pre></td></tr></table></figure><p>包装类型支持自动装箱，我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;    <span class="hljs-comment">//将int类型值作为包装类型使用</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">10</span>);    <span class="hljs-comment">//上面的写法跟这里是等价的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里本质上就是被自动包装成了一个Integer类型的对象，只是语法上为了简单，就支持像这样编写。既然能装箱，也是支持拆箱的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上上面的写法本质上就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> i.intValue();   <span class="hljs-comment">//通过此方法变成基本类型int值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是自动拆箱，得益于包装类型的自动装箱和拆箱机制，我们可以让包装类型轻松地参与到基本类型的运算中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a * b;    <span class="hljs-comment">//直接自动拆箱成基本类型参与到计算中</span><br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为包装类是一个类，不是基本类型，所以说两个不同的对象，那么是不相等的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br><br>    System.out.println(a == b);    <span class="hljs-comment">//虽然a和b的值相同，但是并不是同一个对象，所以说==判断为假</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么自动装箱的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, b = <span class="hljs-number">10</span>;<br>    System.out.println(a == b);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，通过自动装箱转换的Integer对象，如果值相同，得到的会是同一个对象，这是因为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)   <span class="hljs-comment">//这里会有一个IntegerCache，如果在范围内，那么会直接返回已经提前创建好的对象</span><br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>IntegerCache会默认缓存-128到127之间的所有值，将这些值提前做成包装类放在数组中存放，虽然我们目前还没有学习数组，但是各位小伙伴只需要知道，我们如果直接让 -128到127之间的值自动装箱为Integer类型的对象，那么始终都会得到同一个对象，这是为了提升效率，因为小的数使用频率非常高，有些时候并不需要创建那么多对象，创建对象越多，内存也会消耗更多。</p><p>但是如果超出这个缓存范围的话，就会得到不同的对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>, b = <span class="hljs-number">128</span>;<br>    System.out.println(a == b);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就不会得到同一个对象了，因为超出了缓存的范围。同样的，Long、Short、Byte类型的包装类也有类似的机制，感兴趣的小伙伴可以自己点进去看看。</p><p>我们来看看包装类中提供了哪些其他的方法，包装类支持字符串直接转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-string">&quot;666&quot;</span>);   <span class="hljs-comment">//直接将字符串的666，转换为数字666</span><br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，字符串转Integer有多个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-string">&quot;5555&quot;</span>);<br>    <span class="hljs-comment">//Integer i = Integer.parseInt(&quot;5555&quot;);</span><br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>甚至可以对十六进制和八进制的字符串进行解码，得到对应的int值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.decode(<span class="hljs-string">&quot;0xA6&quot;</span>);<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以将十进制的整数转换为其他进制的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(Integer.toHexString(<span class="hljs-number">166</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特殊包装类"><a href="#特殊包装类" class="headerlink" title="特殊包装类"></a>特殊包装类</h3><h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><p>除了我们上面认识的这几种基本类型包装类之外，还有两个比较特殊的包装类型。</p><p>其中第一个是用于计算超大数字的BigInteger，我们知道，即使是最大的long类型，也只能表示64bit的数据，无法表示一个非常大的数，但是BigInteger没有这些限制，我们可以让他等于一个非常大的数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">BigInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> BigInteger.valueOf(Long.MAX_VALUE);    <span class="hljs-comment">//表示Long的最大值，轻轻松松</span><br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过调用类中的方法，进行运算操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">BigInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> BigInteger.valueOf(Long.MAX_VALUE);<br>    i = i.multiply(BigInteger.valueOf(Long.MAX_VALUE));   <span class="hljs-comment">//即使是long的最大值乘以long的最大值，也能给你算出来</span><br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230716184547864.png"></p><p>对于非常大的整数计算，我们就可以使用BigInteger来完成。</p><h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><p>浮点类型精度有限，对于需要精确计算的场景，就没办法了，而BigDecimal可以实现小数的精确计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">10</span>);<br>    i = i.divide(BigDecimal.valueOf(<span class="hljs-number">3</span>), <span class="hljs-number">100</span>, RoundingMode.CEILING);<br>      <span class="hljs-comment">//计算10/3的结果，精确到小数点后100位</span><br>      <span class="hljs-comment">//RoundingMode是舍入模式，就是精确到最后一位时，该怎么处理，这里CEILING表示向上取整</span><br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230716184724714.png"></p><p>但是，对于这种结果没有终点的，无限循环的小数，必须要限制长度，否则会出现异常。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，如何去定义一个数组变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array;   <span class="hljs-comment">//类型[]就表示这个是一个数组类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，数组类型比较特殊，它本身也是类，但是编程不可见（底层C++写的，在运行时动态创建）即使是基本类型的数组，也是以对象的形式存在的，并不是基本数据类型。所以，我们要创建一个数组，同样需要使用<code>new</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];   <span class="hljs-comment">//在创建数组时，需要指定数组长度，也就是可以容纳多个int变量的值</span><br>      <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> array;   <span class="hljs-comment">//因为同样是类，肯定是继承自Object的，所以说可以直接向上转型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>除了上面这种方式之外，我们也可以使用其他方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[数组大小];<br>类型 变量名称[] = <span class="hljs-keyword">new</span> 类型[数组大小];  <span class="hljs-comment">//支持C语言样式，但不推荐！</span><br><br>类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[]&#123;...&#125;;  <span class="hljs-comment">//静态初始化（直接指定值和大小）</span><br>类型[] 变量名称 = &#123;...&#125;;   <span class="hljs-comment">//同上，但是只能在定义时赋值</span><br></code></pre></td></tr></table></figure><p>创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的，要访问数组的某一个元素，我们可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    System.out.println(<span class="hljs-string">&quot;数组的第一个元素为：&quot;</span>+array[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//使用 变量名[下标] 的方式访问</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，数组的下标是从0开始的，不是从1开始的，所以说第一个元素的下标就是0，我们要访问第一个元素，那么直接输入0就行了，但是注意千万别写成负数或是超出范围了，否则会出现异常。</p><p>我们也可以使用这种方式为数组的元素赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    array[<span class="hljs-number">0</span>] = <span class="hljs-number">888</span>;   <span class="hljs-comment">//就像使用变量一样，是可以放在赋值运算符左边的，我们可以直接给对应下标位置的元素赋值</span><br>    System.out.println(<span class="hljs-string">&quot;数组的第一个元素为：&quot;</span>+array[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为数组本身也是一个对象，数组对象也是具有属性的，比如长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    System.out.println(<span class="hljs-string">&quot;当前数组长度为：&quot;</span>+array.length);   <span class="hljs-comment">//length属性是int类型的值，表示当前数组长度，长度是在一开始创建数组的时候就确定好的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，这个<code>length</code>是在一开始就确定的，而且是<code>final</code>类型的，不允许进行修改，也就是说数组的长度一旦确定，不能随便进行修改，如果需要使用更大的数组，只能重新创建。</p><p>当然，既然是类型，那么肯定也是继承自Object类的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    System.out.println(array.toString());<br>    System.out.println(array.equals(array));<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，很遗憾，除了clone()之外，这些方法并没有被重写，也就是说依然是采用的Object中的默认实现</p><p>如果我们要打印整个数组中所有的元素，得一个一个访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        System.out.print(array[i] + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有时候为了方便，我们可以使用简化版的for语句<code>foreach</code>语法来遍历数组中的每一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : array) &#123;    <span class="hljs-comment">//int i就是每一个数组中的元素，array就是我们要遍历的数组</span><br>        System.out.print(i+<span class="hljs-string">&quot; &quot;</span>);   <span class="hljs-comment">//每一轮循环，i都会更新成数组中下一个元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉这种写法更加简洁？只不过这仅仅是语法糖而已，编译之后依然是跟上面一样老老实实在遍历的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;   <span class="hljs-comment">//反编译的结果</span><br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span>[] var2 = array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> array.length;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; var4 &lt; var3; ++var4) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> var2[var4];<br>        System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对于这种普通的数组，其实使用还是挺简单的。这里需要特别说一下，对于基本类型的数组来说，是不支持自动装箱和拆箱的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    Integer[] test = arr;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230716185345421.png"></p><p>由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的：</p><p><img src="/../img/images/image-20230716185429380.png"></p><p>但是如果是引用类型的话，是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];<br>    Object[] array = arr;    <span class="hljs-comment">//数组同样支持向上转型</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Object[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br>    String[] array = (String[]) arr;   <span class="hljs-comment">//也支持向下转型</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">10</span>];    <span class="hljs-comment">//数组类型数组那么就要写两个[]了</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[][] arr = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                    &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                    &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;   <span class="hljs-comment">//一个三行两列的数组</span><br>    System.out.println(arr[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);   <span class="hljs-comment">//访问第三行第二列的元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在访问多维数组时，我们需要使用多次<code>[]</code>运算符来得到对应位置的元素。如果我们要遍历多维数组话，那么就需要多次嵌套循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                                                &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                                                &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;    <span class="hljs-comment">//要遍历一个二维数组，那么我们得一列一列一行一行地来</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>            System.out.println(arr[i][j]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>我们接着来看数组的延伸应用，实际上我们的方法是支持可变长参数的，什么是可变长参数？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String... strings)</span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在使用时，可以传入0 - N个对应类型的实参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    person.test(<span class="hljs-string">&quot;1！&quot;</span>, <span class="hljs-string">&quot;5！&quot;</span>, <span class="hljs-string">&quot;哥们在这跟你说唱&quot;</span>); <span class="hljs-comment">//这里我们可以自由传入任意数量的字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们在方法中怎么才能得到这些传入的参数呢，实际上可变长参数本质就是一个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String... strings)</span>&#123;   <span class="hljs-comment">//strings这个变量就是一个String[]类型的</span><br>    <span class="hljs-keyword">for</span> (String string : strings) &#123;<br>        System.out.println(string);   <span class="hljs-comment">//遍历打印数组中每一个元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果同时存在其他参数，那么可变长参数只能放在最后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, String... strings)</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串类是一个比较特殊的类，它用于保存字符串。我们知道，基本类型<code>char</code>可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列（在C中就是一个字符数组）Java中没有字符串这种基本类型，因此只能使用类来进行定义。注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String本身也是一个类，只不过它比较特殊，每个用双引号括起来的字符串，都是String类型的一个实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以象征性地使用一下new关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);  <span class="hljs-comment">//这种方式就是创建一个新的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    System.out.println(str1 == str2);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果使用构造方法主动创建两个新的对象，那么就是不同的对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    System.out.println(str1 == str2);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是想要判断两个字符串的内容是否相同，不要使用<code>==</code>，String类重载了<code>equals</code>方法用于判断和比较内容是否相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    System.out.println(str1.equals(str2));   <span class="hljs-comment">//字符串的内容比较，一定要用equals</span><br>&#125;<br></code></pre></td></tr></table></figure><p>既然String也是一个类，那么肯定是具有一些方法的，我们可以来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    System.out.println(str.length());   <span class="hljs-comment">//length方法可以求字符串长度，这个长度是字符的数量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为双引号括起来的字符串本身就是一个实例对象，所以说我们也可以直接用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>.length());   <span class="hljs-comment">//虽然看起来挺奇怪的，但是确实支持这种写法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>字符串类中提供了很多方便我们操作的方法，比如字符串的裁剪、分割操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);   <span class="hljs-comment">//分割字符串，并返回一个新的子串对象</span><br>    System.out.println(sub);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    String[] strings = str.split(<span class="hljs-string">&quot; &quot;</span>);   <span class="hljs-comment">//使用split方法进行字符串分割，比如这里就是通过空格分隔，得到一个字符串数组</span><br>    <span class="hljs-keyword">for</span> (String string : strings) &#123;<br>        System.out.println(string);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字符数组和字符串之间是可以快速进行相互转换的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    <span class="hljs-type">char</span>[] chars = str.toCharArray();<br>    System.out.println(chars);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;奥&#x27;</span>, <span class="hljs-string">&#x27;利&#x27;</span>, <span class="hljs-string">&#x27;给&#x27;</span>&#125;;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>字符串支持使用<code>+</code>和<code>+=</code>进行拼接操作。</p><p>但是拼接字符串实际上底层需要进行很多操作，如果程序中大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接会在编译时进行各种优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;杰哥&quot;</span> + <span class="hljs-string">&quot;你干嘛&quot;</span>;    <span class="hljs-comment">//我们在写代码时使用的是拼接的形式</span><br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译之后就变成这样了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;杰哥你干嘛&quot;</span>;<br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于变量来说，也有优化，比如下面这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你看&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;这&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;汉堡&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;做滴&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;行不行&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> str1 + str2 + str3 + str4 + str5;   <span class="hljs-comment">//5个变量连续加</span><br>    System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果直接使用加的话，每次运算都会生成一个新的对象，这里进行4次加法运算，那么中间就需要产生4个字符串对象出来，是不是有点太浪费了？这种情况实际上会被优化为下面的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你看&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;这&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;汉堡&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;做滴&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;行不行&quot;</span>;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    builder.append(str1).append(str2).append(str3).append(str4).append(str5);<br>    System.out.println(builder.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>这里创建了一个StringBuilder的类型，这个类型是干嘛的呢？实际上它就是专门用于构造字符串的，我们可以使用它来对字符串进行拼接、裁剪等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();   <span class="hljs-comment">//一开始创建时，内部什么都没有</span><br>    builder.append(<span class="hljs-string">&quot;AAA&quot;</span>);   <span class="hljs-comment">//我们可以使用append方法来讲字符串拼接到后面</span><br>    builder.append(<span class="hljs-string">&quot;BBB&quot;</span>);<br>    System.out.println(builder.toString());   <span class="hljs-comment">//当我们字符串编辑完成之后，就可以使用toString转换为字符串了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它还支持裁剪等操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;AAABBB&quot;</span>);   <span class="hljs-comment">//在构造时也可以指定初始字符串</span><br>    builder.delete(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);   <span class="hljs-comment">//删除2到4这个范围内的字符</span><br>    System.out.println(builder.toString());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>现在想要实现这样一个功能，对于给定的字符串进行判断，如果字符串符合规则，那么就返回真，否则返回假，比如现在想要判断字符串是不是邮箱的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aaaa731341@163.com&quot;</span>;<br>      <span class="hljs-comment">//假设邮箱格式为 数字/字母@数字/字母.com</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在请你设计一个Java程序用于判断，你该怎么做？是不是感觉很麻烦，使用正则表达式就可以很轻松解决这种字符串格式匹配问题。</p><blockquote><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;oooo&quot;</span>;<br>      <span class="hljs-comment">//matches方法用于对给定正则表达式进行匹配，匹配成功返回true，否则返回false</span><br>    System.out.println(str.matches(<span class="hljs-string">&quot;o+&quot;</span>));   <span class="hljs-comment">//+表示对前面这个字符匹配一次或多次，这里字符串是oooo，正好可以匹配</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用于规定给定组件必须要出现多少次才能满足匹配的，我们一般称为限定符，限定符表如下：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配前面的子表达式零次或多次。例如，<strong>zo*</strong> 能匹配 <strong>“z”</strong> 以及 <strong>“zoo”*<em>。*</em></strong>* 等价于 **{0,}**。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。例如，<strong>zo+</strong> 能匹配 <strong>“zo”</strong> 以及 “**zoo”**，但不能匹配 **”z”*<em>。*</em>+** 等价于 **{1,}**。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次。例如，<strong>do(es)?</strong> 可以匹配 <strong>“do”</strong> 、 **”does”*<em>、 **“doxy”** 中的 **“do”** 。*</em>?** 等价于 **{0,1}**。</td></tr><tr><td>{n}</td><td>n 是一个非负整数。匹配确定的 <strong>n</strong> 次。例如，<strong>o{2}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但是能匹配 <strong>“food”</strong> 中的两个 <strong>o</strong>。</td></tr><tr><td>{n,}</td><td>n 是一个非负整数。至少匹配n 次。例如，<strong>o{2,}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但能匹配 <strong>“foooood”</strong> 中的所有 <strong>o</strong>。<strong>o{1,}</strong> 等价于 *<em>o+*<em>。*<em>o{0,}</em></em> 则等价于 <strong>o</strong></em>。</td></tr><tr><td>{n,m}</td><td>m 和 n 均为非负整数，其中 n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，<strong>o{1,3}</strong> 将匹配 <strong>“fooooood”</strong> 中的前三个 <strong>o</strong>。<strong>o{0,1}</strong> 等价于 **o?**。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><p>如果我们想要表示一个范围内的字符，可以使用方括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcabccaa&quot;</span>;<br>    System.out.println(str.matches(<span class="hljs-string">&quot;[abc]*&quot;</span>));   <span class="hljs-comment">//表示abc这几个字符可以出现 0 - N 次</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于普通字符来说，我可以下面的方式实现多种字符匹配：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><strong>[ABC]</strong></td><td>匹配 <strong>[…]</strong> 中的所有字符，例如 <strong>[aeiou]</strong> 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。</td></tr><tr><td><strong>[^ABC]</strong></td><td>匹配除了 <strong>[…]</strong> 中字符的所有字符，例如 <strong>[^aeiou]</strong> 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母。</td></tr><tr><td><strong>[A-Z]</strong></td><td>[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</td></tr><tr><td><strong>.</strong></td><td>匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]</td></tr><tr><td><strong>[\s\S]</strong></td><td>匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</td></tr><tr><td><strong>\w</strong></td><td>匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</td></tr></tbody></table><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;   <span class="hljs-comment">//内部类也是类，所以说里面也可以有成员变量、方法等，甚至还可以继续套娃一个成员内部类</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;我是成员内部类！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成员内部类和成员方法、成员变量一样，是对象所有的，而不是类所有的，如果要使用成员内部类，那么就需要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();   <span class="hljs-comment">//我们首先需要创建对象</span><br>    Test.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> test.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();   <span class="hljs-comment">//成员内部类的类型名称就是 外层.内部类名称</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同样可以使用成员内部类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>    Test.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> test.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>    inner.test();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，成员内部类也可以使用访问权限控制，如果将其权限改为<code>private</code>，那么就像把成员变量访问权限变成私有一样，外部是无法访问到这个内部类的.</p><p>在成员内部类中，是可以访问到外层的变量的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;我是成员内部类：&quot;</span>+name);<br>                 <span class="hljs-comment">//成员内部类可以访问到外部的成员变量</span><br>              <span class="hljs-comment">//因为成员内部类本身就是某个对象所有的，每个对象都有这样的一个类定义，这里的name是其所依附对象的</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/aQPow8piljRCs2d.png"></p><p>每个类可以创建一个对象，每个对象中都有一个单独的类定义，可以通过这个成员内部类又创建出更多对象，套娃了属于是。</p><p>所以说我们在使用时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;小明&quot;</span>);<br>    Test.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner1</span> <span class="hljs-operator">=</span> a.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();   <span class="hljs-comment">//依附于a创建的对象，那么就是a的</span><br>    inner1.test();<br><br>    <span class="hljs-type">Test</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;小红&quot;</span>);<br>    Test.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner2</span> <span class="hljs-operator">=</span> b.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();  <span class="hljs-comment">//依附于b创建的对象，那么就是b的</span><br>    inner2.test();<br>&#125;<br></code></pre></td></tr></table></figure><p>外部不能访问内部类里面的成员变量</p><p>那么如果内部类中也定义了同名的变量，此时我们怎么去明确要使用的是哪一个呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br><br>        String name;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String name)</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;方法参数的name = &quot;</span>+name);    <span class="hljs-comment">//依然是就近原则，最近的是参数，那就是参数了</span><br>            System.out.println(<span class="hljs-string">&quot;成员内部类的name = &quot;</span>+<span class="hljs-built_in">this</span>.name);   <span class="hljs-comment">//在内部类中使用this关键字，只能表示内部类对象</span><br>            System.out.println(<span class="hljs-string">&quot;成员内部类的name = &quot;</span>+Test.<span class="hljs-built_in">this</span>.name);<br>              <span class="hljs-comment">//如果需要指定为外部的对象，那么需要在前面添加外部类型名称</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>包括对方法的调用和super关键字的使用，也是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br><br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.toString();<span class="hljs-comment">//内部类自己的toString方法</span><br>        <span class="hljs-built_in">super</span>.toString();    <span class="hljs-comment">//内部类父类的toString方法</span><br>        Test.<span class="hljs-built_in">this</span>.toString();   <span class="hljs-comment">//外部类的toSrting方法</span><br>        Test.<span class="hljs-built_in">super</span>.toString();  <span class="hljs-comment">//外部类父类的toString方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以说成员内部类其实在某些情况下使用起来比较麻烦，对于这种成员内部类，我们一般只会在类的内部自己使用。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>成员内部类，它就像成员变量和成员方法一样，是属于对象的，同样的，静态内部类就像静态方法和静态变量一样，是属于类的，我们可以直接创建使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;我是静态内部类！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不需要依附任何对象，我们可以直接创建静态内部类的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Test.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>.Inner();   <span class="hljs-comment">//静态内部类的类名同样是之前的格式，但是可以直接new了</span><br>      inner.test();<br>&#125;<br></code></pre></td></tr></table></figure><p>静态内部类由于是静态的，所以相对外部来说，整个内部类中都处于静态上下文（注意只是相当于外部来说）是无法访问到外部类的非静态内容的：</p><p><img src="/../img/images/image-20230717015120121.png"></p><p>只不过受影响的只是外部内容的使用，内部倒是不受影响，还是跟普通的类一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br><br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是静态内部类：&quot;</span>+name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实也很容易想通，因为静态内部类是属于外部类的，不依附任何对象，那么要是直接访问外部类的非静态属性，那到底访问哪个对象的呢？这样肯定是说不通的。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类就像局部变量一样，可以在方法中定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;    <span class="hljs-comment">//直接在方法中创建局部内部类</span><br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然是在方法中声明的类，那作用范围也就只能在方法中了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;   <span class="hljs-comment">//局部内部类跟局部变量一样，先声明后使用</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;我是局部内部类&quot;</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();   <span class="hljs-comment">//局部内部类直接使用类名就行</span><br>        inner.test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只不过这种局部内部类的形式，使用频率很低，基本上不会用到，所以说了解就行了。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类是使用频率非常高的一种内部类，它是局部内部类的简化版。</p><p>在抽象类和接口中都会含有某些抽象方法需要子类去实现，我们当时已经很明确地说了不能直接通过new的方式去创建一个抽象类或是接口对象，但是我们可以使用匿名内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。</p><p>而我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>() &#123;   <span class="hljs-comment">//在new的时候，后面加上花括号，把未实现的方法实现了</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是匿名内部类的实现!&quot;</span>);<br>        &#125;<br>    &#125;;<br>    student.test();<br>&#125;<br></code></pre></td></tr></table></figure><p>此时这里创建出来的Student对象，就是一个已经实现了抽象方法的对象，这个抽象类直接就定义好了，甚至连名字都没有，就可以直接就创出对象。</p><p>匿名内部类中同样可以使用类中的属性（因为它本质上就相当于是对应类型的子类）所以说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>() &#123;<br>    <span class="hljs-type">int</span> a;   <span class="hljs-comment">//因为本质上就相当于是子类，所以说子类定义一些子类的属性完全没问题</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;我是匿名内部类的实现!&quot;</span>);   <span class="hljs-comment">//直接使用父类中的name变量</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同样的，接口也可以通过这种匿名内部类的形式，直接创建一个匿名的接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Study</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是学习方法！&quot;</span>);<br>        &#125;<br>    &#125;;<br>    study.study();<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，并不是说只有抽象类和接口才可以像这样创建匿名内部类，普通的类也可以，只不过意义不大，一般情况下只是为了进行一些额外的初始化工作而已。</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>前面我们介绍了匿名内部类，我们可以通过这种方式创建一个临时的实现子类。</p><p>特别的，<strong>如果一个接口中有且只有一个待实现的抽象方法</strong>，那么我们可以将匿名内部类简写为Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;我是学习方法！&quot;</span>);   <span class="hljs-comment">//是不是感觉非常简洁！</span><br>      study.study();<br>&#125;<br></code></pre></td></tr></table></figure><p>Lambda表达式的具体规范：</p><ul><li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; &#123; 代码语句，包括返回值 &#125;</code></li><li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li><li>接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）</li></ul><p>比如之前写的Study接口，只要求实现一个无参无返回值的方法，所以说直接就是最简单的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; System.out.println(<span class="hljs-string">&quot;我是学习方法！&quot;</span>);   <span class="hljs-comment">//跟之前流程控制一样，如果只有一行代码花括号可省略</span><br></code></pre></td></tr></table></figure><p>当然，如果有一个参数和返回值的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> (a) -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是学习方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;今天学会了&quot;</span>+a;    <span class="hljs-comment">//实际上这里面就是方法体，该咋写咋写</span><br>    &#125;;<br>    System.out.println(study.study(<span class="hljs-number">10</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果方法体中只有一个返回语句，可以直接省去花括号和<code>return</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> (a) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;今天学会了&quot;</span>+a;   <span class="hljs-comment">//这种情况是可以简化的</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> (a) -&gt; <span class="hljs-string">&quot;今天学会了&quot;</span>+a;<br></code></pre></td></tr></table></figure><p>如果参数只有一个，那么可以省去小括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> a -&gt; <span class="hljs-string">&quot;今天学会了&quot;</span>+a;<br></code></pre></td></tr></table></figure><p>实际上程序员追求的就是写出简洁高效的代码，而Java也在朝这个方向一直努力，近年来从Java 9开始出现的一些新语法基本都是各种各样的简写版本。</p><p>如果一个方法的参数需要的是一个接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    test(a -&gt; <span class="hljs-string">&quot;今天学会了&quot;</span>+a);   <span class="hljs-comment">//参数直接写成lambda表达式</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Study study)</span>&#123;<br>    study.study(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这还只是一部分，对于已经实现的方法，如果想直接作为接口抽象方法的实现，还可以使用方法引用。</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义得一样才行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;   <span class="hljs-comment">//待实现的求和方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么使用时候，可以直接使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> (a, b) -&gt; a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>只不过还能更简单，因为Integer类中默认提供了求两个int值之和的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Integer类中就已经有对应的实现了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，我们可以直接将已有方法的实现作为接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> (a, b) -&gt; Integer.sum(a, b);   <span class="hljs-comment">//直接使用Integer为我们通过好的求和方法</span><br>    System.out.println(study.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，Integer.sum的参数和返回值，跟我们在Study中定义的完全一样，所以说我们可以直接使用方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> Integer::sum;    <span class="hljs-comment">//使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式</span><br>    System.out.println(study.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。任何方法都可以通过方法引用作为实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;<br>    String <span class="hljs-title function_">study</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是普通从成员方法，我们同样需要使用对象来进行方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> main::lbwnb;   <span class="hljs-comment">//成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式</span><br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">lbwnb</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;卡布奇诺今犹在，不见当年倒茶人。&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为现在只需要一个String类型的返回值，由于String的构造方法在创建对象时也会得到一个String类型的结果，所以说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> String::<span class="hljs-keyword">new</span>;    <span class="hljs-comment">//没错，构造方法也可以被引用，使用new表示</span><br>&#125;<br></code></pre></td></tr></table></figure><p>反正只要是符合接口中方法的定义的，都可以直接进行方法引用</p><h2 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h2><p>在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);   <span class="hljs-comment">//当b为0的时候，还能正常运行吗？</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a/b;   <span class="hljs-comment">//没有任何的判断而是直接做计算</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时可以看到，出现了运算异常：</p><p><img src="/../img/images/image-20230717024628063.png"></p><h3 id="异常的类型"><a href="#异常的类型" class="headerlink" title="异常的类型"></a>异常的类型</h3><p>我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自<code>Exception</code>类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！</p><p>异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常，异常也是由类定义的，所有的运行时异常都继承自<code>RuntimeException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    object.toString();   <span class="hljs-comment">//这种情况就会出现运行时异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230718171829616.png"></p><p>异常的另一种类型是编译时异常，编译时异常明确指出可能会出现的异常，在编译阶段就需要进行处理（捕获异常）必须要考虑到出现异常的情况，如果不进行处理，将无法通过编译！默认继承自<code>Exception</code>类的异常都是编译时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br></code></pre></td></tr></table></figure><p>比如Object类中定义的<code>clone</code>方法，就明确指出了在运行的时候会出现的异常。</p><p>还有一种类型是错误，错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如<code>OutOfMemoryError</code>就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    test();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    test();<br>&#125;<br></code></pre></td></tr></table></figure><p>比如这样的一个无限递归的方法，会导致运行过程中无限制地向下调用方法，导致栈溢出：</p><p><img src="/../img/images/image-20230718171947786.png"></p><p>这种情况就是错误了，已经严重到整个程序都无法正常运行了。又比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Object[] objects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[Integer.MAX_VALUE];   <span class="hljs-comment">//这里申请一个超级大数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上我们电脑的内存是有限的，不可能无限制地使用内存来存放变量，所以说如果内存不够用了，会直接：</p><p><img src="/../img/images/image-20230718172031275.png"></p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>异常其实就两大类，一个是编译时异常，一个是运行时异常，我们先来看编译时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestException</span><span class="hljs-params">(String message)</span>&#123;<br>        <span class="hljs-built_in">super</span>(message);   <span class="hljs-comment">//这里我们选择使用父类的带参构造，这个参数就是异常的原因</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译时异常只需要继承Exception就行了，编译时异常的子类有很多很多，仅仅是SE中就有700多个。</p><p>异常多种多样，不同的异常对应着不同的情况，比如在类型转换时出错那么就是类型转换异常，如果是使用一个值为null的变量调用方法，那么就会出现空指针异常。</p><p>运行时异常只需要继承RuntimeException就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestException</span><span class="hljs-params">(String message)</span>&#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>RuntimeException继承自Exception，Exception继承自Throwable：</p><p><img src="/../img/images/image-20230718172234232.png"></p><p>运行时异常同同样也有很多，只不过运行时异常和编译型异常在使用时有一些不同，我们会在后面的学习中慢慢认识。</p><p>当然还有一种类型是Error，它是所有错误的父类，同样是继承自Throwable的。</p><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就可以手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;被除数不能为0&quot;</span>);  <span class="hljs-comment">//使用throw关键字来抛出异常</span><br>    <span class="hljs-keyword">return</span> a / b;<br>&#125;<br></code></pre></td></tr></table></figure><p>异常的抛出同样需要创建一个异常对象出来，我们抛出异常实际上就是将这个异常对象抛出，异常对象携带了我们抛出异常时的一些信息，比如是因为什么原因导致的异常，在RuntimeException的构造方法中我们可以写入原因。</p><p>当出现异常时：</p><p><img src="/../img/images/image-20230718172413066.png"></p><p>程序会终止，并且会打印栈追踪信息，实际上方法之间的调用是有层级关系的，而当异常发生时，方法调用的每一层都会在栈追踪信息中打印出来，比如这里有两个<code>at</code>，实际上就是在告诉我们程序运行到哪个位置时出现的异常，位于最上面的就是发生异常的最核心位置，我们代码的第15行。</p><p>并且这里会打印出当前抛出的异常类型和我们刚刚自定义异常信息。</p><p>注意，如果我们在方法中抛出了一个非运行时异常，那么必须告知函数的调用方我们会抛出某个异常，函数调用方必须要对抛出的这个异常进行对应的处理才可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <span class="hljs-comment">//使用throws关键字告知调用方此方法会抛出哪些异常，请调用方处理好</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;我是编译时异常！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果不同的分支条件会出现不同的异常，那么所有在方法中可能会抛出的异常都需要注明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">throws</span> FileNotFoundException, ClassNotFoundException &#123;  <span class="hljs-comment">//多个异常使用逗号隔开</span><br>    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>();<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，并不是只有非运行时异常可以像这样明确指出，运行时异常也可以，只不过不强制要求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">throws</span> RuntimeException &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>至于如何处理明确抛出的异常，我们会下一个部分中进行讲解。</p><p>最后再提一下，我们在重写方法时，如果父类中的方法表明了会抛出某个异常，只要重写的内容中不会抛出对应的异常我们可以直接省去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>当程序没有按照理想的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息）现在希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//使用try-catch语句进行异常捕获</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        object.toString();<br>    &#125; <span class="hljs-keyword">catch</span> (NullPointerException e)&#123;   <span class="hljs-comment">//因为异常本身也是一个对象，catch中实际上就是用一个局部变量去接收异常</span><br><br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;程序继续正常运行！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以将代码编写到<code>try</code>语句块中，只要是在这个范围内发生的异常，都可以被捕获，使用<code>catch</code>关键字对指定的异常进行捕获，这里捕获的是NullPointerException空指针异常：</p><p><img src="/../img/images/image-20230718173021210.png"></p><p>可以看到，当捕获异常之后，程序可以继续正常运行，并不会像之前一样直接结束掉。</p><p>注意，catch中捕获的类型只能是Throwable的子类，也就是说要么是抛出的异常，要么是错误，不能是其他的任何类型。</p><p>可以在<code>catch</code>语句块中对捕获到的异常进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        object.toString();<br>    &#125; <span class="hljs-keyword">catch</span> (NullPointerException e)&#123;<br>        e.printStackTrace();   <span class="hljs-comment">//打印栈追踪信息</span><br>        System.out.println(<span class="hljs-string">&quot;异常错误信息：&quot;</span>+e.getMessage());   <span class="hljs-comment">//获取异常的错误信息</span><br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;程序继续正常运行！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230718173052117.png"></p><p>如果某个方法明确指出会抛出哪些异常，除非抛出的异常是一个运行时异常，否则必须要使用try-catch语句块进行异常的捕获，不然就无法通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    test(<span class="hljs-number">10</span>);    <span class="hljs-comment">//必须要进行异常的捕获，否则报错</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <span class="hljs-comment">//明确会抛出IOException</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果确实不想在当前这个方法中进行处理，那么可以继续踢皮球，抛给上一级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <span class="hljs-comment">//继续编写throws往上一级抛</span><br>    test(<span class="hljs-number">10</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果已经是主方法了，那么就相当于到顶层了，此时发生异常再往上抛出的话，就会直接交给JVM进行处理，默认会让整个程序终止并打印栈追踪信息。</p><p>注意，如果我们要捕获的异常，是某个异常的父类，那么当发生这个异常时，同样可以捕获到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<br>        arr[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>;    <span class="hljs-comment">//这里发生的是数组越界异常，它是运行时异常的子类</span><br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException e)&#123;  <span class="hljs-comment">//使用运行时异常同样可以捕获到</span><br>        System.out.println(<span class="hljs-string">&quot;捕获到异常&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当代码可能出现多种类型的异常时,希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">//....</span><br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>            <br>&#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e)&#123;<br><br>&#125; <span class="hljs-keyword">catch</span> (RuntimeException e)&#123;<br>            <br>&#125;<br></code></pre></td></tr></table></figure><p>但是要注意一下顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">//....</span><br>&#125; <span class="hljs-keyword">catch</span> (RuntimeException e)&#123;  <span class="hljs-comment">//父类型在前，会将子类的也捕获</span><br><br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;   <span class="hljs-comment">//永远都不会被捕获</span><br><br>&#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e)&#123;   <span class="hljs-comment">//永远都不会被捕获</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">//....</span><br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException | IndexOutOfBoundsException e) &#123;  <span class="hljs-comment">//用|隔开每种类型即可</span><br>        <br>&#125;<br></code></pre></td></tr></table></figure><p>如果简写的话，那么发生这些异常的时候，都会采用统一的方式进行处理了。</p><p>程序运行时，无论是否出现异常，都会在最后执行任务，可以交给<code>finally</code>语句块来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            <br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//无论是否出现异常，都会在最后执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>try</code>语句块至少要配合<code>catch</code>或<code>finally</code>中的一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    a /= <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;  <span class="hljs-comment">//不捕获异常，程序会终止，但在最后依然会执行下面的内容</span><br>    System.out.println(<span class="hljs-string">&quot;lbwnb&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="断言表达式"><a href="#断言表达式" class="headerlink" title="断言表达式"></a>断言表达式</h3><p>可以使用断言表达式来对某些东西进行判断，如果判断失败会抛出错误，只不过默认情况下没有开启断言，需要在虚拟机参数中手动开启一下：</p><p><img src="/../img/images/cAG8kY395fOuTLg.png"></p><p>开启断言之后，就可以开始使用了。</p><p>断言表达式需要使用到<code>assert</code>关键字，如果assert后面的表达式判断结果为false，将抛出AssertionError错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">assert</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如可以判断变量的值，如果大于10就抛出错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">assert</span> a &gt; <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以在表达式的后面添加错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">assert</span> a &gt; <span class="hljs-number">10</span> : <span class="hljs-string">&quot;我是自定义的错误信息&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就会显示到错误后面了：</p><p><img src="/../img/images/NaYk5pFiBPLXVIr.png"></p><p>断言表达式一般只用于测试</p><h2 id="常用工具类介绍"><a href="#常用工具类介绍" class="headerlink" title="常用工具类介绍"></a>常用工具类介绍</h2><p>前面学习了包装类、数组和字符串，接着来看看常用的一些工具类。工具类就是专门为一些特定场景编写的，便于去使用的类，工具类一般都会内置大量的静态方法，可以通过类名直接使用。</p><h3 id="数学工具类"><a href="#数学工具类" class="headerlink" title="数学工具类"></a>数学工具类</h3><p>Java提供的运算符实际上只能进行一些在小学数学中出现的运算，但是如果我们想要进行乘方、三角函数之类的高级运算，就没有对应的运算符能够做到，而此时我们就可以使用数学工具类来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//Math也是java.lang包下的类，所以说默认就可以直接使用</span><br>    System.out.println(Math.pow(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));   <span class="hljs-comment">//我们可以使用pow方法直接计算a的b次方</span><br>  <br>      Math.abs(-<span class="hljs-number">1</span>);    <span class="hljs-comment">//abs方法可以求绝对值</span><br>      Math.max(<span class="hljs-number">19</span>, <span class="hljs-number">20</span>);    <span class="hljs-comment">//快速取最大值</span><br>      Math.min(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);   <span class="hljs-comment">//快速取最小值</span><br>      Math.sqrt(<span class="hljs-number">9</span>);    <span class="hljs-comment">//求一个数的算术平方根</span><br>&#125;<br></code></pre></td></tr></table></figure><p>三角函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.sin(Math.PI / <span class="hljs-number">2</span>);     <span class="hljs-comment">//求π/2的正弦值，这里我们可以使用预置的PI进行计算</span><br>Math.cos(Math.PI);       <span class="hljs-comment">//求π的余弦值</span><br>Math.tan(Math.PI / <span class="hljs-number">4</span>);    <span class="hljs-comment">//求π/4的正切值</span><br><br>Math.asin(<span class="hljs-number">1</span>);     <span class="hljs-comment">//三角函数的反函数也是有的，这里是求arcsin1的值</span><br>Math.acos(<span class="hljs-number">1</span>);<br>Math.atan(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>可能在某些情况下，计算出来的浮点数会得到一个很奇怪的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(Math.sin(Math.PI));   <span class="hljs-comment">//计算 sinπ 的结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230718174328761.png"></p><p>sinπ的结果应该是0才对，这其实是科学计数法的10，后面的数就是指数，上面的结果其实就是：</p><ul><li>1.2246467991473532×10−161.2246467991473532×10−16</li></ul><p>其实这个数是非常接近于0，这是因为精度问题导致的，所以说实际上结果就是0。</p><p>快速计算对数函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Math.log(Math.E);    <span class="hljs-comment">//e为底的对数函数，其实就是ln，我们可以直接使用Math中定义好的e</span><br>    Math.log10(<span class="hljs-number">100</span>);     <span class="hljs-comment">//10为底的对数函数</span><br>    <span class="hljs-comment">//利用换底公式，我们可以弄出来任何我们想求的对数函数</span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Math.log(<span class="hljs-number">4</span>) / Math.log(<span class="hljs-number">2</span>);   <span class="hljs-comment">//这里是求以2为底4的对数，log(2)4 = ln4 / ln2</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一些比较特殊的计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Math.ceil(<span class="hljs-number">4.5</span>);    <span class="hljs-comment">//通过使用ceil来向上取整</span><br>    Math.floor(<span class="hljs-number">5.6</span>);   <span class="hljs-comment">//通过使用floor来向下取整</span><br>&#125;<br></code></pre></td></tr></table></figure><p>向上取整就是找一个大于当前数字的最小整数，向下取整就是砍掉小数部分。注意，如果是负数的话，向上取整就是去掉小数部分，向下取整就是找一个小于当前数字的最大整数。</p><p>生成随机数，Java中想要生成一个随机数其实也很简单，我们需要使用Random类来生成（这个类时java.util包下的，需要手动导入才可以）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();   <span class="hljs-comment">//创建Random对象</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>        System.out.print(random.nextInt(<span class="hljs-number">100</span>)+<span class="hljs-string">&quot; &quot;</span>);  <span class="hljs-comment">//nextInt方法可以指定创建0 - x之内的随机数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只不过，程序中的随机并不是真随机，而是根据某些东西计算出来的，只不过计算过程非常复杂，能够在一定程度上保证随机性（根据爱因斯坦理论，宏观物质世界不存在真随机，看似随机的事物只是现目前无法计算而已，唯物主义的公理之一就是任何事物都有因果关系）</p><h3 id="数组工具类"><a href="#数组工具类" class="headerlink" title="数组工具类"></a>数组工具类</h3><p>操作数组实在是有点麻烦，可以使用数组工具类Arrays。</p><p>这个类也是<code>java.util</code>包下类，它用于便捷操作数组，比如想要打印数组，可以直接通过toString方法转换字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p>将数组进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    Arrays.sort(arr);    <span class="hljs-comment">//可以对数组进行排序，将所有的元素按照从小到大的顺序排放</span><br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p>数组中的内容也可以快速进行填充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    Arrays.fill(arr, <span class="hljs-number">66</span>);<br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以快速地对一个数组进行拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span>[] target = Arrays.copyOf(arr, <span class="hljs-number">5</span>);<br>    System.out.println(Arrays.toString(target));   <span class="hljs-comment">//拷贝数组的全部内容，并生成一个新的数组对象</span><br>    System.out.println(arr == target);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span>[] target = Arrays.copyOfRange(arr, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);   <span class="hljs-comment">//也可以只拷贝某个范围内的内容</span><br>    System.out.println(Arrays.toString(target));<br>    System.out.println(arr == target);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以将一个数组中的内容拷贝到其他数组中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span>[] target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    System.arraycopy(arr, <span class="hljs-number">0</span>, target, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);   <span class="hljs-comment">//使用System.arraycopy进行搬运</span><br>    System.out.println(Arrays.toString(target));<br>&#125;<br></code></pre></td></tr></table></figure><p>对于一个有序的数组（从小到大排列）我们可以使用二分搜索快速找到对应的元素在哪个位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    System.out.println(Arrays.binarySearch(arr, <span class="hljs-number">5</span>));   <span class="hljs-comment">//二分搜索仅适用于有序数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那要是现在我们使用的是多维数组呢？因为现在数组里面的每个元素就是一个数组，所以说toString会出现些问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>&#125;&#125;;<br>    System.out.println(Arrays.toString(array));<br>&#125;<br></code></pre></td></tr></table></figure><p>Arrays也支持对多维数组进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>&#125;&#125;;<br>    System.out.println(Arrays.deepToString(array));    <span class="hljs-comment">//deepToString方法可以对多维数组进行打印</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，因为数组本身没有重写equals方法，所以说无法判断两个不同的数组对象中的每一个元素是否相同，Arrays也为一维数组和多维数组提供了相等判断的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>&#125;&#125;;<br>    <span class="hljs-type">int</span>[][] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>&#125;&#125;;<br>    System.out.println(Arrays.equals(a, b));   <span class="hljs-comment">//equals仅适用于一维数组</span><br>    System.out.println(Arrays.deepEquals(a, b));   <span class="hljs-comment">//对于多维数组，需要使用deepEquals来进行深层次判断</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为什么这里的deepEquals接受的是<code>Object[]</code>也可以传入参数呢？这是因为现在是二维数组，二维数组每个元素都是一个数组，而数组本身的话就是一个引用类型了，所以说可以转换为Object类型，但是如果是一维数组的话，就报错</p>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE（二）-面向对象编程基础</title>
    <link href="/2023/03/02/JavaSE%EF%BC%88%E4%BA%8C%EF%BC%89-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2023/03/02/JavaSE%EF%BC%88%E4%BA%8C%EF%BC%89-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程基础"><a href="#面向对象编程基础" class="headerlink" title="面向对象编程基础"></a>面向对象编程基础</h1><span id="more"></span><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>人类、鸟类、鱼类… 所谓类，就是对一类事物的描述，是抽象的、概念上的定义，比如鸟类，就泛指所有具有鸟类特征的动物。比如人类，不同的人，有着不同的性格、不同的爱好、不同的样貌等等，但是他们根本上都是人，所以说可以将他们抽象描述为人类。</p><p>对象是某一类事物实际存在的每个个体，因而也被称为实例（instance）每个人都是人类的一个实际存在的个体。</p><p>类就是抽象概念的人，而对象，就是具体的某一个人。</p><ul><li>A：是谁拿走了我的手机？</li><li>B：是个人。（某一个类）</li><li>A：我还知道是个人呢，具体是谁呢？</li><li>B：是XXX。（具体某个对象）</li></ul><h3 id="类的定义与对象创建"><a href="#类的定义与对象创建" class="headerlink" title="类的定义与对象创建"></a>类的定义与对象创建</h3><p>右键<code>src</code>目录，点击创建新的类</p><p>对类进行命名时，一般使用英文单词，并且首字母大写，跟变量命名一样，不能出现任何的特殊字符。</p><p>既然是人类，那么肯定有人相关的一些属性，比如名字、性别、年龄等等，可以将这些属性直接作为类的成员变量（成员变量相当于是这个类所具有的属性，每个实例创建出来之后，这些属性都可能会各不相同）定义到类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些变量只有在一个具体的对象中才可以使用。</p><p>创建一个实例对象了，实例对应的应该是一个具体的人：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类名();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();   <span class="hljs-comment">//可以使用new关键字来创建某个类的对象，注意new后面需要跟上 类名()</span><br>      <span class="hljs-comment">//这里创建出来的，就是一个具体的人了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>整个流程为：</p><ul><li>创建类</li><li>类的属性</li><li>类定义完成</li><li>通过new关键字创建一个具体的对象</li></ul><h3 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h3><p>同样可以使用一个变量来指代某个对象，只不过引用类型的变量，存储的是对象的引用，而不是对象本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//这里的a存放的是具体的某个值</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>      <span class="hljs-comment">//创建一个变量指代刚刚创建好的对象，变量的类型就是对应的类名</span><br>      <span class="hljs-comment">//这里的p存放的是对象的引用，而不是本体，可以通过对象的引用来间接操作对象</span><br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> p1;<br>    System.out.println(p1 == p2);    <span class="hljs-comment">//使用 == 可以判断两个变量引用的是不是同一个对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果像这样去编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();   <span class="hljs-comment">//这两个变量分别引用的是不同的两个对象</span><br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    System.out.println(p1 == p2);   <span class="hljs-comment">//如果两个变量存放的是不同对象的引用，那么肯定就是不一样的了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有了对象的引用之后，就可以进行操作了：</p><p>可以直接访问对象的一些属性，也就是在类中定义好的那些，对于不同的对象，这些属性都具体存放值也会不同。</p><p>修改对象的名字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    p.name = <span class="hljs-string">&quot;小明&quot;</span>;   <span class="hljs-comment">//要访问对象的属性，需要使用 . 运算符</span><br>    System.out.println(p.name);   <span class="hljs-comment">//直接打印对象的名字，就是刚刚修改好的结果了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不同对象的属性是分开独立存放的，每个对象都有一个自己的空间，修改一个对象的属性并不会影响到其他对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    p1.name = <span class="hljs-string">&quot;小明&quot;</span>;   <span class="hljs-comment">//这个修改的是第一个对象的属性</span><br>    p2.name = <span class="hljs-string">&quot;大明&quot;</span>;   <span class="hljs-comment">//这里修改的是第二个对象的属性</span><br>    System.out.println(p1.name);  <span class="hljs-comment">//这里获取的是第一个对象的属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关于对象类型的变量，也可以不对任何对象进行引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">//null是一个特殊的值，它表示空，也就是不引用任何的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果不引用任何的对象，那肯定是不应该去通过这个变量去操作所引用的对象的</p><p>虽然这样可以编译通过，但是在运行时会出现问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;   <span class="hljs-comment">//此时变量没有引用任何对象</span><br>    p.name = <span class="hljs-string">&quot;小红&quot;</span>;   <span class="hljs-comment">//我任性，就是要操作</span><br>    System.out.println(p.name);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230715174032065.png"></p><p>出现的是空指针异常，很明显是因为去操作一个值为null的变量导致的。</p><p>对象创建成功之后，它的属性没有进行赋值，但是前面说了，变量使用之前需要先赋值，那么创建对象之后能否直接访问呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    System.out.println(<span class="hljs-string">&quot;name = &quot;</span>+p.name);<br>    System.out.println(<span class="hljs-string">&quot;age = &quot;</span>+p.age);<br>    System.out.println(<span class="hljs-string">&quot;sex = &quot;</span>+p.sex);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230715174212247.png"></p><p>如果直接创建对象，那么对象的属性都会存在初始值，如果是基本类型，那么默认是统一为<code>0</code>（如果是boolean的话，默认值为false）如果是引用类型，那么默认是<code>null</code>。</p><h3 id="方法创建与使用"><a href="#方法创建与使用" class="headerlink" title="方法创建与使用"></a>方法创建与使用</h3><p>方法的定义如下：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">返回值类型 方法名称() </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">        方法体...</span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure><p>首先是返回值类型，也就是说这个方法完成任务之后，得到的结果的数据类型（可以是基本类型，也可以是引用类型）当然，如果没有返回值，只是完成任务，那么可以使用<code>void</code>表示没有返回值，比如现在给人类编写一个自我介绍的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>      <span class="hljs-comment">//自我介绍只需要完成就行，没有返回值，所以说使用void</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>          <span class="hljs-comment">//完成自我介绍需要执行的所有代码就在这个花括号中编写</span><br>          <span class="hljs-comment">//这里编写代码跟之前在main中是一样的（实际上main就是一个函数）</span><br>          <span class="hljs-comment">//自我介绍需要用到当前对象的名字和年龄，直接使用成员变量即可，变量的值就是当前对象的存放值</span><br>        System.out.println(<span class="hljs-string">&quot;我叫 &quot;</span>+name+<span class="hljs-string">&quot; 今年 &quot;</span>+age+<span class="hljs-string">&quot; 岁了！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意，方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。</p></blockquote><p>怎么才能让对象执行这个行为呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    p.name = <span class="hljs-string">&quot;小明&quot;</span>;<br>    p.age = <span class="hljs-number">3</span>;<br>    p.hello();    <span class="hljs-comment">//只需要使用 . 运算符，就可以执行定义好的方法了，只需要 .方法名称() 即可</span><br>&#125;<br></code></pre></td></tr></table></figure><p>像这样执行定义好的方法，一般称为<strong>方法的调用</strong></p><p><img src="/../img/images/image-20230715174614147.png"></p><p>比如现在要让人类学会加法运算，也可以通过定义一个方法的形式来完成，只不过，要完成加法运算，需要别人给人类提供两个参与加法运算的值才可以，所以这里就要用到参数了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//的方法需要别人提供参与运算的值才可以</span><br><span class="hljs-comment">//可以为方法设定参数，在调用方法时，需要外部传入参数才可以</span><br><span class="hljs-comment">//参数的定义需要在小括号内部编写，类似于变量定义，需要填写 类型和参数名称，多个参数用逗号隔开</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;   <span class="hljs-comment">//这里需要两个int类型的参数进行计算</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在参数从外部传入之后，怎么使用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;   <span class="hljs-comment">//这里的参数，相当于在函数中定义了两个局部变量，可以直接在方法中使用</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;   <span class="hljs-comment">//直接c = a + b</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在计算完成了，该怎么将结果传递到外面呢？首先函数的返回值是int类型，只需要使用<code>return</code>关键字来返回一个int类型的结果就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>    <span class="hljs-keyword">return</span> c;   <span class="hljs-comment">//return后面紧跟需要返回的结果，这样就可以将计算结果丢出去了</span><br>      <span class="hljs-comment">//带返回值的方法，是一定要有一个返回结果的！否则无法通过编译！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    p.name = <span class="hljs-string">&quot;小明&quot;</span>;<br>    p.age = <span class="hljs-number">18</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> p.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);    <span class="hljs-comment">//现在要让这个对象帮计算10 + 20的结果</span><br>    System.out.println(result);    <span class="hljs-comment">//成功得到30，实际上这里的println也是在调用方法进行打印操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>方法定义时编写的参数，一般称为形式参数，而调用方法实际传入的参数，则是实际参数。</p><p>关于<code>return</code>关键字</p><p>使用<code>return</code>关键字之后，方法就会直接结束并返回结果，所以说在这之后编写的任何代码，都是不可到达的：</p><p><img src="/../img/images/image-20230715174850320.png"></p><p>在<code>return</code>后编写代码，会导致编译不通过，因为存在不可达语句。</p><p>如果的程序中出现了分支语句，那么必须保证每一个分支都有返回值才可以：</p><p><img src="/../img/images/image-20230715174953849.png"></p><p>只要有任何一个分支缺少了<code>return</code>语句，都无法正常通过编译，总之就是必须考虑到所有的情况，任何情况下都必须要有返回值。</p><p>当然，如果方法没有返回值，我也可以使用<code>return</code>语句，不需要跟上任何内容，只不过这种情况下使用，仅仅是为了快速结束方法的执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//当a等于10时直接结束方法，后面无论有没有代码都不会执行了</span><br>    System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);   <span class="hljs-comment">//不是的情况就正常执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>参数的传递问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;   <span class="hljs-comment">//可以设置参数来让外部的数据传入到函数内部</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上参数的传递，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是传入的变量本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;   <span class="hljs-comment">//这个函数的目的很明显，就是为了交换a和b的值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a;<br>    a = b;<br>    b = a;<br>&#125;<br></code></pre></td></tr></table></figure><p>来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>, b = <span class="hljs-number">9</span>;   <span class="hljs-comment">//外面也叫a和b</span><br>    p.swap(a, b);<br>    System.out.println(<span class="hljs-string">&quot;a = &quot;</span>+a+<span class="hljs-string">&quot;, b = &quot;</span>+b);   <span class="hljs-comment">//最后的结果会变成什么样子呢？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>看看结果是什么：</p><p><img src="/../img/images/image-20230715175248444.png"></p><p>所以说交换的仅仅是方法中的a和b，参数传递仅仅是值传递，是没有办法直接操作到外面的a和b的。</p><p>看看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(Person person)</span>&#123;<br>    person.name = <span class="hljs-string">&quot;lbwnb&quot;</span>;   <span class="hljs-comment">//修改对象的名称</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    p.name = <span class="hljs-string">&quot;小明&quot;</span>;     <span class="hljs-comment">//先在外面修改一次</span><br>    p.modify(p);        <span class="hljs-comment">//调用方法再修改一次</span><br>    System.out.println(p.name);    <span class="hljs-comment">//请问最后name会是什么？</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230715175515870.png"></p><p>这里同样是进行的值传递，但是，引用类型的变量，仅仅存放的是对象的引用，而不是对象本身。那么这里进行了值传递，相当于将对象的引用复制到了方法内部的变量中，而这个内部的变量，依然是引用的同一个对象，所以说这里在方法内操作，相当于直接操作外面的定义对象。</p><h3 id="方法进阶使用"><a href="#方法进阶使用" class="headerlink" title="方法进阶使用"></a>方法进阶使用</h3><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>方法中可能会出现一些与成员变量重名的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//希望使用这个方法，来为当前对象设定名字</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>此时类中定义的变量名称也是<code>name</code>，那么是否可以这样编写呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>    name = name;    <span class="hljs-comment">//出现重名时，优先使用作用域最接近的，这里实际上是将方法参数的局部变量name赋值为本身</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    p.setName(<span class="hljs-string">&quot;小明&quot;</span>);<br>    System.out.println(p.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>似乎这样做并没有任何的效果，name依然是没有修改的状态。那么当出现重名的时候，因为默认情况下会优先使用作用域最近的变量，怎么才能表示要使用的变量是类的成员变量呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p.name = <span class="hljs-string">&quot;小明&quot;</span>;    <span class="hljs-comment">//之前在外面使用时，可以直接通过对象.属性的形式访问到</span><br></code></pre></td></tr></table></figure><p>同样的，如果想要在方法中访问到当前对象的属性，那么可以使用<code>this</code>关键字，来明确表示当前类的示例对象本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;   <span class="hljs-comment">//让当前对象的name变量值等于参数传入的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以修改成功了，当然，如果方法内没有变量出现重名的情况，那么默认情况下可以不使用<code>this</code>关键字来明确表示当前对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name;    <span class="hljs-comment">//这里没有使用this，但是当前作用域下只有对象属性的name变量，所以说直接就使用了</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>有些时候，参数类型可能会多种多样，的方法需要能够同时应对多种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    System.out.println(p.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));    <span class="hljs-comment">//这里可以正常计算两个整数的和</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是要是现在不仅要让人类会计算整数，还要会计算小数呢？</p><p><img src="/../img/images/image-20230716152936179.png"></p><p>当使用小数时，可以看到，参数要求的是int类型，那么肯定会出现错误，这个方法只能用于计算整数。此时，为了让这个方法支持使用小数进行计算，可以将这个方法进行重载。</p><p>一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>&#123;    <span class="hljs-comment">//为了支持小数加法，可以进行一次重载</span><br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以正常使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>      <span class="hljs-comment">//当方法出现多个重载的情况，在调用时会自动进行匹配，选择合适的方法进行调用</span><br>    System.out.println(p.sum(<span class="hljs-number">1.5</span>, <span class="hljs-number">2.2</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>包括之前一直在使用的<code>println</code>方法，其实也是重载了很多次的，因为要支持各种值的打印。</p><p>注意，如果仅仅是返回值的不同，是不支持重载的</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>前面创建对象，都是直接使用<code>new</code>关键字就能直接搞定了，但是，对象在创建之后，各种属性都是默认值，那么能否实现在对象创建时就为其指定名字、年龄、性别呢？要在对象创建时进行处理，可以使用构造方法（构造器）来完成。</p><p>实际上每个类都有一个默认的构造方法，可以来看看反编译的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//反编译中，多出来了这样一个方法，这其实就是构造方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用去写，编译出来就自带）当然，也可以手动声明，对其进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    Person()&#123;    <span class="hljs-comment">//构造方法不需要指定返回值，并且方法名称与类名相同</span><br>        name = <span class="hljs-string">&quot;小明&quot;</span>;   <span class="hljs-comment">//构造方法会在对象创建时执行，可以将各种需要初始化的操作都在这里进行处理</span><br>        age = <span class="hljs-number">18</span>;<br>        sex = <span class="hljs-string">&quot;男&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法会在new的时候自动执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();   <span class="hljs-comment">//这里的new Person()其实就是在调用无参构造方法</span><br>    System.out.println(p.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，也可以为构造方法设定参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    Person(String name, <span class="hljs-type">int</span> age, String sex)&#123;   <span class="hljs-comment">//跟普通方法是一样的</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非手动重载一个无参构造，否则要创建这个类的对象，必须调用自己定义的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);   <span class="hljs-comment">//调用自己定义的带三个参数的构造方法</span><br>    System.out.println(p.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以去看看反编译的结果，会发现此时没有无参构造了，而是只剩下自己编写的。</p><p>当然，要给成员变量设定初始值不仅可以通过构造方法，也可以直接在定义时赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;未知&quot;</span>;   <span class="hljs-comment">//直接赋值，那么对象构造好之后，属性默认就是这个值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;男&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要特别注意，成员变量的初始化，并不是在构造方法之前之后，而是在这之前就已经完成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Person(String name, <span class="hljs-type">int</span> age, String sex)&#123;<br>    System.out.println(age);    <span class="hljs-comment">//在赋值之前看看是否有初始值</span><br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.sex = sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以在类中添加代码块，代码块同样会在对象构造之前进行，在成员变量初始化之后执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是代码块&quot;</span>);   <span class="hljs-comment">//代码块中的内容会在对象创建时仅执行一次</span><br>    &#125;<br><br>    Person(String name, <span class="hljs-type">int</span> age, String sex)&#123;<br>        System.out.println(<span class="hljs-string">&quot;我被构造了&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只不过一般情况下使用代码块的频率比较低，标准情况下还是通过构造方法进行进行对象初始化工作，所以说这里做了解就行了。</p><h3 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h3><p>一个类可以具有多种属性、行为，包括对象该如何创建，可以通过构造方法进行设定，可以通过类创建对象，每个对象都会具有在类中设定好的属性，包括设定好的行为，所以说类就像是一个模板，可以通过这个模板快速捏造出一个又一个的对象。接着来看比较特殊的静态特性。</p><p>静态的内容，可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br>    <span class="hljs-keyword">static</span> String info;    <span class="hljs-comment">//这里定义一个info静态变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    p1.info = <span class="hljs-string">&quot;杰哥你干嘛&quot;</span>;<br>    System.out.println(p2.info);   <span class="hljs-comment">//可以看到，由于静态属性是属于类的，因此无论通过什么方式改变，都改变的是同一个目标</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以说一般情况下，并不会通过一个具体的对象去修改和使用静态属性，而是通过这个类去使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Person.info = <span class="hljs-string">&quot;让我看看&quot;</span>;<br>    System.out.println(Person.info);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，可以将方法标记为静态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是静态方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>静态方法同样是属于类的，而不是具体的某个对象，所以说，就像下面这样：</p><p><img src="/../img/images/cWCrJgnkXFL63y2.png"></p><p>成员变量是某个具体对象拥有的属性，就像小明这个具体的人的名字才叫小明，而静态方法是类具有的，并不是具体对象的，肯定是没办法访问到的。同样的，在静态方法中，无法使用<code>this</code>关键字，因为this关键字代表的是当前的对象本身。</p><p>但是静态方法是可以访问到静态变量的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String info;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;静态变量的值为：&quot;</span>+info);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为他们都属于类，所以说肯定是可以访问到的。</p><p>也可以将代码块变成静态的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String info;<br><br><span class="hljs-keyword">static</span> &#123;   <span class="hljs-comment">//静态代码块可以用于初始化静态变量</span><br>    info = <span class="hljs-string">&quot;测试&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，静态变量，是在什么时候进行初始化的呢？</p><p>实际上是将<code>.class</code>文件丢给JVM去执行的，而每一个<code>.class</code>文件其实就是编写的一个类，在Java中使用一个类之前，JVM并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类：</p><ul><li>访问类的静态变量，或者为静态变量赋值</li><li>new 创建类的实例（隐式加载）</li><li>调用类的静态方法</li><li>子类初始化时</li><li>其他的情况会在讲到反射时介绍</li></ul><p>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</p><p>可以来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> test();  <span class="hljs-comment">//这里用test方法的返回值作为变量的初始值，便于观察</span><br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是普通代码块&quot;</span>);<br>    &#125;<br>    <br>    Person()&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是构造方法&quot;</span>);<br>    &#125;<br>    <br>    String <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是成员变量初始化&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;小明&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> init();   <span class="hljs-comment">//这里用init静态方法的返回值作为变量的初始值，便于观察</span><br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是静态代码块&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是静态变量初始化&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在在主方法中创建一个对象，观察这几步是怎么在执行的：</p><p><img src="/../img/images/image-20230716154825352.png"></p><p>可以看到，确实是静态内容在对象构造之前的就完成了初始化，实际上就是类初始化时完成的。</p><p>当然，如果直接访问类的静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(Person.info);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么此时同样会使得类初始化，进行加载：</p><p><img src="/../img/images/image-20230716154947566.png"></p><p>可以看到，在使用时，确实是先将静态内容初始化之后，才得到值的。当然，如果压根就没有去使用这个类，那么也不会被初始化了。</p><h2 id="包和访问控制"><a href="#包和访问控制" class="headerlink" title="包和访问控制"></a>包和访问控制</h2><h3 id="包声明和导入"><a href="#包声明和导入" class="headerlink" title="包声明和导入"></a>包声明和导入</h3><p>包其实就是用来区分类位置的东西，也可以用来将的类进行分类（类似于C++中的namespace）随着的程序不断变大，可能会创建各种各样的类，他们可能会做不同的事情，那么这些类如果都放在一起的话，有点混乱，可以通过包的形式将这些类进行分类存放。</p><p>包的命名规则同样是英文和数字的组合，最好是一个域名的格式，比如经常访问的<code>www.baidu.com</code>，后面的baidu.com就是域名，的包就可以命名为<code>com.baidu</code>，当然，各位小伙伴现在还没有自己的域名，所以说随便起一个名称就可以了。其中的<code>.</code>就是用于分割的，对应多个文件夹</p><p>之前都是直接创建的类，所以说没有包这个概念，但是现在将类放到包中，就需要注意了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;   <span class="hljs-comment">//在放入包中，需要在类的最上面添加package关键字来指明当前类所处的包</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;   <span class="hljs-comment">//将Main类放到com.test这个包中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里又是一个新的关键字<code>package</code>，这个是用于指定当前类所处的包的，注意，所处的包和对应的目录是一一对应的。</p><p>不同的类可以放在不同的包下</p><p>当使用同一个包中的类时，直接使用即可（之前就是直接使用的，因为都直接在一个缺省的包中）而当需要使用其他包中的类时，需要先进行导入才可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> com.test.entity.Person;   <span class="hljs-comment">//使用import关键字导入其他包中的类</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();   <span class="hljs-comment">//只有导入之后才可以使用，否则编译器不知道这个类从哪来的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用了<code>import</code>关键字导入需要使用的类，当然，只有在类不在同一个包下时才需要进行导入，如果一个包中有多个类，可以使用<code>*</code>表示导入这个包中全部的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.test.entity.*;<br></code></pre></td></tr></table></figure><p>实际上之前一直在使用的<code>System</code>类，也是在一个包中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Executable;<br><span class="hljs-keyword">import</span> java.lang.annotation.Annotation;<br><span class="hljs-keyword">import</span> java.security.AccessControlContext;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><span class="hljs-keyword">import</span> java.util.PropertyPermission;<br><span class="hljs-keyword">import</span> java.util.StringTokenizer;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.security.AccessController;<br><span class="hljs-keyword">import</span> java.security.PrivilegedAction;<br><span class="hljs-keyword">import</span> java.security.AllPermission;<br><span class="hljs-keyword">import</span> java.nio.channels.Channel;<br><span class="hljs-keyword">import</span> java.nio.channels.spi.SelectorProvider;<br><span class="hljs-keyword">import</span> sun.nio.ch.Interruptible;<br><span class="hljs-keyword">import</span> sun.reflect.CallerSensitive;<br><span class="hljs-keyword">import</span> sun.reflect.Reflection;<br><span class="hljs-keyword">import</span> sun.security.util.SecurityConstants;<br><span class="hljs-keyword">import</span> sun.reflect.annotation.AnnotationType;<br><br><span class="hljs-keyword">import</span> jdk.internal.util.StaticProperty;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The &lt;code&gt;System&lt;/code&gt; class contains several useful class fields</span><br><span class="hljs-comment"> * and methods. It cannot be instantiated.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;/code&gt; class</span><br><span class="hljs-comment"> * are standard input, standard output, and error output streams;</span><br><span class="hljs-comment"> * access to externally defined properties and environment</span><br><span class="hljs-comment"> * variables; a means of loading files and libraries; and a utility</span><br><span class="hljs-comment"> * method for quickly copying a portion of an array.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  unascribed</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>   JDK1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">System</span> &#123;<br>      ...<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它是属于<code>java.lang</code>这个包下的类，并且这个类也导入了很多其他包中的类在进行使用。那么，为什么在使用这个类时，没有导入呢？实际上Java中会默认导入<code>java.lang</code>这个包下的所有类，因此不需要手动指定。</p><p>IDEA非常智能，在使用项目中定义的类时，会自动帮将导入补全，所以说代码写起来非常高效。</p><p>注意，在不同包下的类，即使类名相同，也是不同的两个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.entity;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;    <span class="hljs-comment">//在自己的包中也建一个名为String的类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只需要在类名前面把完整的包名也给写上，就可以表示这个是哪一个包里的类了，当然，如果没有出现歧义，默认情况下包名是可以省略的，可写可不写。</p><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p>实际上Java中是有访问权限控制的，就是个人的隐私的一样，我不允许别人随便来查看的隐私，只有自己同意的情况下，才能告诉别人的名字、年龄等隐私信息。</p><p>所以说Java中引入了访问权限控制（可见性），可以为成员变量、成员方法、静态变量、静态方法甚至是类指定访问权限，不同的访问权限，有着不同程度的访问限制：</p><ul><li><code>private</code> - 私有，标记为私有的内容无法被除当前类以外的任何位置访问。</li><li><code>什么都不写</code> - 默认，默认情况下，只能被类本身和同包中的其他类访问。</li><li><code>protected</code> - 受保护，标记为受保护的内容可以能被类本身和同包中的其他类访问，也可以被子类访问（子类会在下一章介绍）</li><li><code>public</code> - 公共，标记为公共的内容，允许在任何地方被访问。</li></ul><p>这四种访问权限，总结如下表：</p><table><thead><tr><th></th><th>当前类</th><th>同一个包下的类</th><th>不同包下的子类</th><th>不同包下的类</th></tr></thead><tbody><tr><td>public</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>protected</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>默认</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>private</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table><p>比如刚刚出现的情况，就是因为是默认的访问权限，所以说在当前包以外的其他包中无法访问，但是可以提升它的访问权限，来使得外部也可以访问：</p><h2 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a>封装、继承和多态</h2><p>封装、继承和多态是面向对象编程的三大特性。</p><blockquote><p>封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。</p><p>继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。</p><p>多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。</p></blockquote><p>正是这三大特性，让Java程序更加生动形象。</p><h3 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h3><p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要使用Getter和Setter方法来查看和设置变量。</p><p>可以将之前的类进行改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">//现在类的属性只能被自己直接访问</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String sex;<br>  <br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;   <span class="hljs-comment">//构造方法也要声明为公共，否则对象都构造不了</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;    <span class="hljs-comment">//想要知道这个对象的名字，必须通过getName()方法来获取，并且得到的只是名字值，外部无法修改</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以来试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    System.out.println(person.getName());    <span class="hljs-comment">//只能通过调用getName()方法来获取名字</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，外部现在只能通过调用定义的方法来获取成员属性，而可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含”小”这个字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">if</span>(name.contains(<span class="hljs-string">&quot;小&quot;</span>)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br></code></pre></td></tr></table></figure><p>甚至还可以将构造方法改成私有的，需要通过的内部的方式来构造对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;&#125;   <span class="hljs-comment">//不允许外部使用new关键字创建对象</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Person <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//而是需要使用的独特方法来生成对象并返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，可以实现单例模式：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Test instance;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Test <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) <br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单例模式就是全局只能使用这一个对象，不能创建更多的对象</p></blockquote><p>封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现，要用什么由类自己来做，不需要外面来操作类内部的东西去完成，封装就是通过访问权限控制来实现的。</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中<strong>非私有</strong>的成员。</p><p><img src="/../img/images/zlZ9JXAjvxpawPF.png"></p><p>实际上这些划分出来的类，本质上还是人类，也就是说人类具有的属性，这些划分出来的类同样具有，但是，这些划分出来的类同时也会拥有他们自己独特的技能。在Java中，可以创建一个类的子类来实现上面的这种效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;   <span class="hljs-comment">//先定义一个父类</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着可以创建各种各样的子类，想要继承一个类，只需要使用<code>extends</code>关键字即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;    <span class="hljs-comment">//工人类</span><br>    <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;   <span class="hljs-comment">//学生类</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>类的继承可以不断向下，但是同时只能继承一个类，同时，标记为<code>final</code>的类不允许被继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-comment">//class前面添加final关键字表示这个类已经是最终形态，不能继承</span><br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为<code>private</code>，那么子类将无法访问（但是依然是继承了这个属性的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我的名字是 &quot;</span>+name+<span class="hljs-string">&quot;，我在学习！&quot;</span>);   <span class="hljs-comment">//可以直接访问父类中定义的name属性</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，在父类中定义的方法同样会被子类继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我叫 &quot;</span>+name+<span class="hljs-string">&quot;，今年 &quot;</span>+age+<span class="hljs-string">&quot; 岁了!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子类直接获得了此方法，当创建一个子类对象时就可以直接使用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.study();    <span class="hljs-comment">//子类不仅有自己的独特技能</span><br>    student.hello();    <span class="hljs-comment">//还继承了父类的全部技能</span><br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉非常人性化，子类继承了父类的全部能力，同时还可以扩展自己的独特能力，就像一句话说的： 龙生龙凤生凤，老鼠儿子会打洞。</p><p>如果父类存在一个有参构造方法，子类必须在构造方法中调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">protected</span> String name;   <span class="hljs-comment">//因为子类需要用这些属性，所以说就将这些变成protected，外部不允许访问</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">protected</span> String sex;<br>    <span class="hljs-keyword">protected</span> String profession;<br><br>      <span class="hljs-comment">//构造方法也改成protected，只能子类用</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex, String profession)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        <span class="hljs-built_in">this</span>.profession = profession;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;[&quot;</span>+profession+<span class="hljs-string">&quot;] 我叫 &quot;</span>+name+<span class="hljs-string">&quot;，今年 &quot;</span>+age+<span class="hljs-string">&quot; 岁了!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为子类在构造时，不仅要初始化子类的属性，还需要初始化父类的属性，所以说在默认情况下，子类其实是调用了父类的构造方法的，只是在无参的情况下可以省略，但是现在父类构造方法需要参数，那么就需要手动指定了</p><p><img src="/../img/images/image-20230716160809322.png"></p><p>既然现在父类需要三个参数才能构造，那么子类需要按照同样的方式调用父类的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;    <span class="hljs-comment">//因为学生职业已经确定，所以说学生直接填写就可以了</span><br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;学生&quot;</span>);   <span class="hljs-comment">//使用super代表父类，父类的构造方法就是super()</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我的名字是 &quot;</span>+name+<span class="hljs-string">&quot;，我在学习！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;工人&quot;</span>);    <span class="hljs-comment">//父类构造调用必须在最前面</span><br>        System.out.println(<span class="hljs-string">&quot;工人构造成功！&quot;</span>);    <span class="hljs-comment">//注意，在调用父类构造方法之前，不允许执行任何代码，只能在之后执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用子类时，可以将其当做父类来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);    <span class="hljs-comment">//这里使用父类类型的变量，去引用一个子类对象（向上转型）</span><br>    person.hello();    <span class="hljs-comment">//父类对象的引用相当于当做父类来使用，只能访问父类对象的内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这里使用的是父类类型引用的对象，但是这并不代表子类就彻底变成父类了，这里仅仅只是当做父类使用而已。</p><p>也可以使用强制类型转换，将一个被当做父类使用的子类对象，转换回子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) person;   <span class="hljs-comment">//使用强制类型转换（向下转型）</span><br>    student.study();<br>&#125;<br></code></pre></td></tr></table></figure><p>但是注意，这种方式只适用于这个对象本身就是对应的子类才可以，如果本身都不是这个子类，或者说就是父类，那么会出现问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);   <span class="hljs-comment">//实际创建的是Work类型的对象</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) person;<br>    student.study();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230716161449827.png"></p><p>此时直接出现了类型转换异常，因为本身不是这个类型，强转也没用。</p><p>那么如果想要判断一下某个变量所引用的对象到底是什么类，那么该怎么办呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-keyword">if</span>(person <span class="hljs-keyword">instanceof</span> Student) &#123;   <span class="hljs-comment">//可以使用instanceof关键字来对类型进行判断</span><br>        System.out.println(<span class="hljs-string">&quot;对象是 Student 类型的&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(person <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        System.out.println(<span class="hljs-string">&quot;对象是 Person 类型的&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果变量所引用的对象是对应类型或是对应类型的子类，那么<code>instanceof</code>都会返回<code>true</code>，否则返回<code>false</code>。</p><p>最后需要来特别说明一下，子类是可以定义和父类同名的属性的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">protected</span> String name;   <span class="hljs-comment">//子类中同样可以定义name属性</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;工人&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时父类的name属性和子类的name属性是同时存在的，那么当在子类中直接使用时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是 &quot;</span>+name+<span class="hljs-string">&quot;，我在工作！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以说，在使用时，实际上这里得到的结果为<code>null</code>：</p><p><img src="/../img/images/image-20230716161826506.png"></p><p>那么，在子类存在同名变量的情况下，怎么去访问父类的呢？同样可以使用<code>super</code>关键字来表示父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是 &quot;</span>+<span class="hljs-built_in">super</span>.name+<span class="hljs-string">&quot;，我在工作！&quot;</span>);   <span class="hljs-comment">//这里使用super.name来表示需要的是父类的name变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230716161906875.png"></p><p>但是注意，没有<code>super.super</code>这种用法，也就是说如果存在多级继承的话，那么最多只能通过这种方法访问到父类的属性（包括继承下来的属性）</p><h3 id="顶层Object类"><a href="#顶层Object类" class="headerlink" title="顶层Object类"></a>顶层Object类</h3><p>实际上所有类都默认继承自Object类，除非手动指定继承的类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：</p><p><img src="/../img/images/image-20230716162248592.png"></p><p>除了自己在类中编写的方法之外，还可以调用一些其他的方法，那么这些方法不可能无缘无故地出现，肯定同样是因为继承得到的，那么这些方法是继承谁得到的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span>&#123;   <br><span class="hljs-comment">//除非手动指定要继承的类是什么，实际上默认情况下所有的类都是继承自Object的，只是可以省略</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>所以说继承结构差不多就是：</p><p><img src="/../img/images/hkapOYVHBrjy7UC.png"></p><p>既然所有的类都默认继承自Object，来看看这个类里面有哪些内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerNatives</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//标记为native的方法是本地方法，底层是由C++实现的</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        registerNatives();   <span class="hljs-comment">//这个类在初始化时会对类中其他本地方法进行注册</span><br>    &#125;<br><br>    <span class="hljs-comment">//获取当前的类型Class对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();<br><br>    <span class="hljs-comment">//获取对象的哈希值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br>      <span class="hljs-comment">//判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>    &#125;<br>  <br>    <span class="hljs-comment">//克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br><br>    <span class="hljs-comment">//将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>    &#125;<br><br>    <span class="hljs-comment">//唤醒一个等待当前对象锁的线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//唤醒所有等待当前对象锁的线程，同上</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//使得持有当前对象锁的线程进入等待状态，同上</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-comment">//同上</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">//同上</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">//当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法会在JVM篇视频教程中详细介绍，目前暂时不会用到</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以尝试调用一下Object为提供的<code>toString()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> person.toString();<br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是按照上面说的格式进行打印：</p><p><img src="/../img/images/hpBOjqf4iwJW1Pr.png"></p><p>当然，直接可以给<code>println</code>传入一个Object类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">(Object x)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(x);   <span class="hljs-comment">//这里同样会调用对象的toString方法，所以说跟上面效果是一样的</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        print(s);<br>        newLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里不是接受的一个Object类型的值的，为什么任意类型都可以传入呢？因为所有类型都是继承自Object，如果方法接受的参数是一个引用类型的值，那只要是这个类的对象或是这个类的子类的对象，都可以作为参数传入。</p><p>也可以试试看默认提供的<code>equals</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    System.out.println(p1.equals(p2));<br>&#125;<br></code></pre></td></tr></table></figure><p>因为默认比较的是两个对象是否为同一个对象，所以说这里得到的肯定是false，但是有些情况下，实际上所希望的情况是如果名字、年龄、性别都完全相同，那么这肯定是同一个人，但是这里却做不到这样的判断，需要修改一下<code>equals</code>方法的默认实现来完成，这就要用到方法的重写了。</p><h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p>方法的重载是为某个方法提供更多种类，而方法的重写是覆盖原有的方法实现，比如现在不希望使用Object类中提供的<code>equals</code>方法，那么就可以将其重写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    ...<br><br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//重写方法可以添加 @Override 注解，有关注解会在最后一章进行介绍，这个注解默认情况下可以省略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;   <span class="hljs-comment">//重写方法要求与父类的定义完全一致</span><br>        <span class="hljs-keyword">if</span>(obj == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">//如果传入的对象为null，那肯定不相等</span><br>        <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> Person) &#123;     <span class="hljs-comment">//只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么</span><br>            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) obj;   <span class="hljs-comment">//先转换为当前类型，接着对三个属性挨个进行比较</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.equals(person.name) &amp;&amp;    <span class="hljs-comment">//字符串内容的比较，不能使用==，必须使用equals方法</span><br>                    <span class="hljs-built_in">this</span>.age == person.age &amp;&amp;       <span class="hljs-comment">//基本类型的比较跟之前一样，直接==</span><br>                    <span class="hljs-built_in">this</span>.sex.equals(person.sex);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在重写Object提供的<code>equals</code>方法之后，就会按照的方式进行判断了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    System.out.println(p1.equals(p2));   <span class="hljs-comment">//此时由于三个属性完全一致，所以说判断结果为真，即使是两个不同的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有时候为了方便查看对象的各个属性，可以将Object类提供的<code>toString</code>方法重写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//使用IDEA可以快速生成</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>            <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&quot;, profession=&#x27;&quot;</span> + profession + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，直接打印对象时，就会打印出对象的各个属性值了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    System.out.println(person);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，静态方法不支持重写，因为它是属于类本身的，但是它可以被继承。</p><p>基于这种方法可以重写的特性，对于一个类定义的行为，不同的子类可以出现不同的行为，比如考试，学生考试可以得到A，而工人去考试只能得到D：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    ...<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是考试方法&quot;</span>);<br>    &#125;<br>  <br>      ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    ...<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是学生，我就是小镇做题家，拿个 A 轻轻松松&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    ...<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，不同的子类，对于同一个方法会产生不同的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    person.exam();<br><br>    person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&quot;小强&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    person.exam();<br>&#125;<br></code></pre></td></tr></table></figure><p>这其实就是面向对象编程中多态特性的一种体现。</p><p>注意，如果不希望子类重写某个方法，可以在方法前添加<code>final</code>关键字，表示这个方法已经是最终形态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是考试方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>或者，如果父类中方法的可见性为<code>private</code>，那么子类同样无法访问，也就不能重写，但是可以定义同名方法：</p><p>虽然这里可以编译通过，但是并不是对父类方法的重写，仅仅是子类自己创建的一个新方法。</p><p>还有，在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用<code>super</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.exam();   <span class="hljs-comment">//调用父类的实现</span><br>    System.out.println(<span class="hljs-string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是访问权限的问题，子类在重写父类方法时，不能降低父类方法中的可见性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是考试方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为子类实际上可以当做父类使用，如果子类的访问权限比父类还低，那么在被当做父类使用时，就可能出现无视访问权限调用的情况，这样肯定是不行的，但是相反的，可以在子类中提升权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是考试方法&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//将可见性提升为public </span><br>    System.out.println(<span class="hljs-string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到作为子类时就可以正常调用，但是如果将其作为父类使用，因为访问权限不足所有就无法使用，总之，子类重写的方法权限不能比父类还低</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>越是处于顶层定义的类，实际上可以进一步地进行抽象，比如前面编写的考试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是考试方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法再子类中一定会被重写，所以说除非子类中调用父类的实现，否则一般情况下永远都不会被调用，就像说一个人会不会考试一样，实际上人怎么考试是一个抽象的概念，而学生怎么考试和工人怎么考试，才是具体的一个实现，所以说，可以将人类进行进一步的抽象，让某些方法完全由子类来实现，父类中不需要提供实现。</p><p>要实现这样的操作，可以将人类变成抽象类，抽象类比类还要抽象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;   <span class="hljs-comment">//通过添加abstract关键字，表示这个类是一个抽象类</span><br>    <span class="hljs-keyword">protected</span> String name;   <span class="hljs-comment">//大体内容其实普通类差不多</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">protected</span> String sex;<br>    <span class="hljs-keyword">protected</span> String profession;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex, String profession)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        <span class="hljs-built_in">this</span>.profession = profession;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;工人&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//子类必须要实现抽象类所有的抽象方法，这是强制要求的，否则会无法通过编译</span><br>        System.out.println(<span class="hljs-string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象类由于不是具体的类定义（它是类的抽象）可能会存在某些方法没有实现，因此无法直接通过new关键字来直接创建对象：</p><p><img src="/../img/images/image-20230716165310878.png"></p><p>要使用抽象类，只能去创建它的子类对象。</p><p>抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;   <span class="hljs-comment">//如果抽象类的子类也是抽象类，那么可以不用实现父类中的抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;学生&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//抽象类中并不是只能有抽象方法，抽象类中也可以有正常方法的实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是学生，我就是小镇做题家，拿个 A 轻轻松松&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/1ZJSRU2Aj5K9Ikv.png" alt="image-20220921232435056"></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口一般只代表某些功能的抽象，接口包含了一些列方法的定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p><p>咋一看，这啥意思啊，什么叫支持接口代表的功能？实际上接口的目标就是将类所具有某些的行为抽象出来。</p><p>比如说，对于人类的不同子类，学生和老师来说，他们都具有学习这个能力，既然都有，那么就可以将学习这个能力，抽象成接口来进行使用，只要是实现这个接口的类，都有学习的能力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;    <span class="hljs-comment">//使用interface表示这是一个接口</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以让类实现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Study</span> &#123;   <span class="hljs-comment">//使用implements关键字来实现接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;学生&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//实现接口时，同样需要将接口中所有的抽象方法全部实现</span><br>        System.out.println(<span class="hljs-string">&quot;我会学习！&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Study</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Teacher</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;教师&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我会加倍学习！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口不同于继承，接口可以同时实现多个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Study</span>, A, B, C &#123;  <span class="hljs-comment">//多个接口的实现使用逗号隔开</span><br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>所以说有些人说接口其实就是Java中的多继承，但是我个人认为这种说法是错的，实际上实现接口更像是一个类的功能列表，作为附加功能存在，一个类可以附加很多个功能，接口的使用和继承的概念有一定的出入，顶多说是多继承的一种替代方案。</p><p>接口跟抽象类一样，不能直接创建对象，但是也可以将接口实现类的对象以接口的形式去使用：</p><p><img src="/../img/images/image-20230716182648660.png"></p><p>当做接口使用时，只有接口中定义的方法和Object类的方法，无法使用类本身的方法和父类的方法。</p><p>接口同样支持向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;小王&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-keyword">if</span>(study <span class="hljs-keyword">instanceof</span> Teacher) &#123;   <span class="hljs-comment">//直接判断引用的对象是不是Teacher类型</span><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> (Teacher) study;   <span class="hljs-comment">//强制类型转换</span><br>        teacher.study();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里的使用其实跟之前的父类是差不多的。</p><p>从Java8开始，接口中可以存在方法的默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//使用default关键字为接口中的方法添加默认实现</span><br>        System.out.println(<span class="hljs-string">&quot;我是默认实现&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。</p><p>接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法，在接口中定义的变量只能是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;   <span class="hljs-comment">//接口中定义的静态变量只能是public static final的</span><br>  <br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">//接口中定义的静态方法也只能是public的</span><br>        System.out.println(<span class="hljs-string">&quot;我是静态方法&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟普通的类一样，可以直接通过接口名.的方式使用静态内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(Study.a);<br>    Study.test();<br>&#125;<br></code></pre></td></tr></table></figure><p>接口是可以继承自其他接口的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> exetnds B &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>并且接口没有继承数量限制，接口支持多继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> exetnds B, C, D &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>接口的继承相当于是对接口功能的融合罢了。</p><p>Object类中提供的克隆方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Cloneable</span> &#123;    <span class="hljs-comment">//这个接口中什么都没定义</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实现接口后，还需要将克隆方法的可见性提升一下，不然还用不了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Study</span>, Cloneable &#123;   <span class="hljs-comment">//首先实现Cloneable接口，表示这个类具有克隆的功能</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;学生&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;   <span class="hljs-comment">//提升clone方法的访问权限</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();   <span class="hljs-comment">//因为底层是C++实现，直接调用父类的实现就可以了</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我会学习！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着来尝试一下，看看是不是会得到一个一模一样的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;  <span class="hljs-comment">//这里向上抛出一下异常，还没学异常，所以说照着写就行了</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">clone</span> <span class="hljs-operator">=</span> (Student) student.clone();   <span class="hljs-comment">//调用clone方法，得到一个克隆的对象</span><br>    System.out.println(student);<br>    System.out.println(clone);<br>    System.out.println(student == clone);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，原对象和克隆对象，是两个不同的对象，但是他们的各种属性都是完全一样的：</p><p><img src="/../img/images/image-20230716183004807.png"></p><blockquote><p>克隆操作可以完全复制一个对象的所有属性，但是像这样的拷贝操作其实也分为浅拷贝和深拷贝。</p><ul><li><strong>浅拷贝：</strong>对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。</li><li><strong>深拷贝：</strong>无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。</li></ul><p>那么clone方法出来的克隆对象，是深拷贝的结果还是浅拷贝的结果呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">clone</span> <span class="hljs-operator">=</span> (Student) student.clone();<br>    System.out.println(student.name == clone.name);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/gpM1iukyoSdn2RE.png"></p><p>可以看到，虽然Student对象成功拷贝，但是其内层对象并没有进行拷贝，依然只是对象引用的复制，所以Java为提供的<code>clone</code>方法只会进行浅拷贝。</p></blockquote><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>假设现在想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Study</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String status;   <span class="hljs-comment">//状态，可以是跑步、学习、睡觉这三个之中的其中一种</span><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getStatus</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStatus</span><span class="hljs-params">(String status)</span> &#123;<br>        <span class="hljs-built_in">this</span>.status = status;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样会出现一个问题，如果仅仅是存储字符串，似乎外部可以不按照规则，传入一些其他的字符串。这显然是不够严谨的，有没有一种办法，能够更好地去实现这样的状态标记呢？希望开发者拿到使用的就是预先定义好的状态，所以，可以使用枚举类来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> &#123;   <span class="hljs-comment">//enum表示这是一个枚举类，枚举类的语法稍微有一些不一样</span><br>    RUNNING, STUDY, SLEEP;    <span class="hljs-comment">//直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用枚举类也非常方便，就像使用普通类型那样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Status status;   <span class="hljs-comment">//类型变成刚刚定义的枚举类</span><br><br><span class="hljs-keyword">public</span> Status <span class="hljs-title function_">getStatus</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStatus</span><span class="hljs-params">(Status status)</span> &#123;<br>    <span class="hljs-built_in">this</span>.status = status;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230716183558722.png"></p><p>枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自<code>Enum</code>类，定义的每一个状态其实就是一个<code>public static final</code>的Status类型成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里使用javap命令对class文件进行反编译得到 Compiled from &quot;Status.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.test.Status <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Enum&lt;com.test.Status&gt; &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status RUNNING;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status STUDY;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status SLEEP;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.Status[] values();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.Status <span class="hljs-title function_">valueOf</span><span class="hljs-params">(java.lang.String)</span>;<br>  <span class="hljs-keyword">static</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然枚举类型是普通的类，那么也可以给枚举类型添加独有的成员方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> &#123;<br>    RUNNING(<span class="hljs-string">&quot;睡觉&quot;</span>), STUDY(<span class="hljs-string">&quot;学习&quot;</span>), SLEEP(<span class="hljs-string">&quot;睡觉&quot;</span>);   <span class="hljs-comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法）</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-comment">//枚举的成员变量</span><br>    Status(String name)&#123;    <span class="hljs-comment">//覆盖原有构造方法（默认private，只能内部使用！）</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//获取封装的成员变量</span><br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，枚举就可以按照想要的中文名称打印了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    student.setStatus(Status.RUNNING);<br>    System.out.println(student.getStatus().getName());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE（一）-面向过程编程</title>
    <link href="/2023/03/01/JavaSE%EF%BC%88%E4%B8%80%EF%BC%89-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/03/01/JavaSE%EF%BC%88%E4%B8%80%EF%BC%89-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="面向过程编程"><a href="#面向过程编程" class="headerlink" title="面向过程编程"></a>面向过程编程</h1><span id="more"></span><h2 id="Java程序基础"><a href="#Java程序基础" class="headerlink" title="Java程序基础"></a>Java程序基础</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>使用双斜杠<code>//</code>（单行注释）</li><li>多行可以使用<code>/*</code>和<code>*/</code>的组合来囊括需要编写的注释内容</li><li>使用<code>/**</code>来进行更加详细的文档注释</li></ul><h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><blockquote><p>变量，指值可以变的量。变量以非<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97/6204?fromModule=lemma_inlink">数字</a>的符号来表达，一般用拉丁字母。变量的用处在于能一般化描述指令的方式。结果只能使用真实的值，指令只能应用于某些情况下。变量能够作为某特定种类的值中任何一个的保留器。</p></blockquote><p>在Java中，我们也可以让变量去代表一个具体的值，并且变量的值是可以发生变化的。</p><p>要声明一个变量，需要使用以下格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[数据类型] [变量名称];<br></code></pre></td></tr></table></figure><p>变量要求：</p><ul><li><p>标识符可以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。</p></li><li><p>变量不能重复定义，大小写敏感，比如A和a就是两个不同的变量。</p></li><li><p>不能有空格、@、#、+、-、&#x2F; 等符号。</p></li><li><p>应该使用有意义的名称，达到见名知意的目的（一般我们采用英文单词），最好以小写字母开头。</p></li><li><p>不可以是 true 和 false。</p></li><li><p>不能与Java语言的关键字或是基本数据类型重名，关键字列表如下：</p><p><img src="/../img/images/I6nCh49qzyvoZBm.png"></p></li></ul><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>有时候希望变量的值一直保持不变，可以将其指定为常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">666</span>;   <span class="hljs-comment">//在变量前面添加final关键字，表示这是一个常量</span><br>    a = <span class="hljs-number">777</span>;    <span class="hljs-comment">//常量的值不允许发生修改</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编译时出现：</p><p><img src="/../img/images/kT46yi8KNOLWlp3.png"></p><p>常量的值只有第一次赋值可以修改，其他任何情况下都不行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> a;<br>    a = <span class="hljs-number">777</span>;   <span class="hljs-comment">//第一次赋值</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="计算机中的二进制表示"><a href="#计算机中的二进制表示" class="headerlink" title="计算机中的二进制表示"></a>计算机中的二进制表示</h3><p>在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1&#x3D;10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1&#x3D;10&#x3D;2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。</p><p>这里的bit跟生活中的网速MB&#x2F;s是不一样的，小b代表的是bit，大B代表的是Byte字节（8bit &#x3D; 1Byte字节），办理宽带的时候，100Mbps这里的b是小写的，所以说实际的网速就是100&#x2F;8 &#x3D; 12.5 MB&#x2F;s了。</p><blockquote><p>十进制的7 -&gt; 在二进制中为 111 &#x3D; 2^2 + 2^1 + 2^0</p></blockquote><p>现在有4个bit位，最大能够表示多大的数字呢？</p><ul><li>最小：0000 &#x3D;&gt; 0</li><li>最大：1111 &#x3D;&gt; 23+22+21+20 &#x3D;&gt; 8 + 4 + 2 + 1 &#x3D; 15</li></ul><p>在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：</p><ul><li>最小：1111 &#x3D;&gt; -(22+21+2^0) &#x3D;&gt; -7</li><li>最大：0111 &#x3D;&gt; +(22+21+2^0) &#x3D;&gt; +7 &#x3D;&gt; 7</li></ul><p>现在，4bit能够表示的范围变为了-7~+7，这样的表示方式称为<strong>原码</strong>。虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：</p><blockquote><p>1+(-1) &#x3D; 0001 + 1001 &#x3D; 怎么让计算机去计算？</p></blockquote><p>得创造一种更好的表示方式！于是引入了<strong>反码</strong>：</p><ul><li>正数的反码是其本身</li><li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反</li></ul><p>经过上面的定义，再来进行加减法：</p><blockquote><p>1+(-1) &#x3D; 0001 + 1110 &#x3D; 1111 &#x3D;&gt; -0 </p></blockquote><p>思考：1111代表-0，0000代表+0，在实数的范围内，0有正负之分吗？0既不是正数也不是负数，那么显然这样的表示依然不够合理！根据上面的问题，我们引入了最终的解决方案，那就是<strong>补码</strong>，定义如下：</p><ul><li>正数的补码就是其本身 （不变！）</li><li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1（即在反码的基础上+1，此时1000表示-8）</li><li>对补码再求一次补码就可得该补码对应的原码。</li></ul><p>比如-7原码为1111，反码为1000，补码就是1001了，-6原码为1110，反码为1001，补码就是1010。所以在补码下，原本的1000就作为新增的最小值-8存在。</p><p>所以现在就已经能够想通，-0已经被消除了！再来看上面的运算：</p><blockquote><p>1+(-1) &#x3D; 0001 + 1111 &#x3D; (1)0000 &#x3D;&gt; +0 </p></blockquote><p>所以现在，1111代表的不再是-0，而是-1，相应的，由于消除-0，负数多出来一个可以表示的数（1000拿去表示-8了），那么此时4bit位能够表示的范围是：-8~+7（Java使用的就是补码）</p><h3 id="整型类型"><a href="#整型类型" class="headerlink" title="整型类型"></a>整型类型</h3><p>在Java中，整数类型包括以下几个：</p><ul><li>byte 字节型 （8个bit，也就是1个字节）范围：-128~+127</li><li>short 短整形（16个bit，也就是2个字节）范围：-32768~+32767</li><li>int 整形（32个bit，也就是4个字节）最常用的类型：-2147483648 ~ +2147483647</li><li>long 长整形（64个bit，也就是8个字节）范围：-9223372036854775808 ~ +9223372036854775807</li></ul><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>这几种变量都可以正常表示整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为都可以表示整数，所以可以将小的整数类型值传递给大的整数类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;   <span class="hljs-comment">//小的类型可以直接传递给表示范围更大的类型</span><br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>反之会出现报错：</p><p><img src="/../img/images/image-20230713224445219.png"></p><p>在将小的整数类型传递给大的整数类型时发生了<strong>隐式类型转换</strong>，只要是从存储范围小的类型到存储范围大的类型，都支持隐式类型转换，它可以自动将某种类型的值，转换为另一种类型，比如上面就是将short类型的值转换为了int类型的值。</p><p>为变量赋一个常量数值时，也发生了隐式类型转换，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>   <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;    <span class="hljs-comment">//这里的整数常量10，实际上默认情况下是int类型，但是由于正好在对应类型可以表示的范围内，所以说直接转换为了byte类型的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于直接编写的整数常量值默认为<code>int</code>，这里需要特别注意一下，比如下面这种情况：</p><p><img src="/../img/images/image-20230714002735680.png"></p><p>按照<code>long</code>类型的规定，实际上是可以表示这么大的数字的，我们直接在代码中写的常量数字，默认情况下就是<code>int</code>类型，这么大肯定是表示不下的，如果需要将其表示为一个long类型的常量数字，需要在后面添加大写或是小写的<code>L</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">922337203685477580L</span>;   <span class="hljs-comment">//正常编译通过</span><br>&#125;<br></code></pre></td></tr></table></figure><p>针对于这种很长的数字，为了提升辨识度，可以使用下划线分割每一位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000</span>;    <span class="hljs-comment">//当然这里依然表示的是1000000，没什么区别，但是辨识度会更高</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以以8进制或是16进制表示一个常量值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-number">0xA</span>);<br>    System.out.println(<span class="hljs-number">012</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="超出数值最大值"><a href="#超出数值最大值" class="headerlink" title="超出数值最大值"></a>超出数值最大值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2147483647</span>;   <span class="hljs-comment">//int最大值</span><br>    a = a + <span class="hljs-number">1</span>;   <span class="hljs-comment">//继续加</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>此时a的值已经来到了<code>int</code>类型所能表示的最大值了，那么如果此时再继续<code>+1</code>，</p><p><img src="/../img/images/image-20230714003411170.png"></p><p>当int为最大值时，二进制表示形式为什么：</p><ul><li>2147483647 &#x3D; 01111111 11111111 11111111 11111111（第一个是符号位0，其他的全部为1，就是正数的最大值）</li></ul><p>那么此时如果加1，会进位成：</p><ul><li>10000000 00000000 00000000 00000000</li></ul><p>符号位为1，那么此时表示的不就是一个负数了吗？根据补码表示规则，瞬间就能明白了，这不就是补码形式下的最小值了吗？</p><p>所以说最后的结果就是<code>int</code>类型的最小值：-2147483648。</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>Java中的小数类型包含哪些：</p><ul><li>float 单精度浮点型 （32bit，4字节）</li><li>double 双精度浮点型（64bit，8字节）</li></ul><p><img src="/../img/images/CpI5jaWgR9nqTbc.png"></p><p>根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：<br>$$<br>V&#x3D;(−1)<br>S<br> ×M×2<br>E<br>$$</p><ul><li>(−1)�(−1)<em>S</em> 表示符号位，当 S&#x3D;0，V 为正数；当 S&#x3D;1，V 为负数。</li><li>M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为1111010，那么M实际上就是1.111010，尾数首位必须是1，1后面紧跟小数点，如果出现0001111这样的情况，去掉前面的0，移动1到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为1，故为了能够存放更多数据，就舍去了第一位，比如保存1.0101 的时候， 只保存 0101，这样能够多存储一位数据）</li><li>2�2<em>E</em> 表示指数位。（用于移动小数点，所以说才称为浮点型）</li></ul><p>比如， 对于十进制的 5.25 对应的二进制为：101.01，相当于：1.0101×221.0101×22。所以，S 为 0，M 为 1.0101，E 为 2。因此，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码，所以浮点类型的大致取值范围：</p><ul><li>单精度：±3.40282347×1038±3.40282347×1038</li><li>双精度：±1.79769313486231570×10308±1.79769313486231570×10308</li></ul><p>跟整数类型常量一样，小数类型常量默认都是<code>double</code>类型，所以说如果我们直接给一个float类型赋值：</p><p><img src="/../img/images/image-20230714161440632.png"></p><p>由于<code>float</code>类型的精度不如<code>double</code>，如果直接给其赋一个double类型的值，会直接出现错误。</p><p>同样的，可以给常量后面添加大写或小写的F来表示这是一个<code>float</code>类型的常量值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">9.9F</span>;   <span class="hljs-comment">//这样就可以正常编译通过了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是反之，由于<code>double</code>精度更大，所以说可以直接接收<code>float</code>类型的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">9.9F</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> f;    <span class="hljs-comment">//隐式类型转换为double值</span><br>    System.out.println(a);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>只不过由于精度问题，最后的打印结果：</p><p><img src="/../img/images/image-20230714161339889.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">21731371236768L</span>;<br>    <span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> l;   <span class="hljs-comment">//这里能编译通过吗？</span><br>    System.out.println(f);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>long</code>类型的值居然可以直接丢给<code>float</code>类型隐式类型转换，很明显<code>float</code>只有32个bit位，而<code>long</code>有足足64个，这是什么情况？怎么大的还可以隐式转换为小的？这是因为虽然<code>float</code>空间没有那么大，但是由于是浮点类型，指数可以变化，最大的数值表示范围实际上是大于<code>long</code>类型的，虽然会丢失精度，但是确实可以表示这么大的数。</p><blockquote><p>总结一下隐式类型转换规则：byte→short(char)→int→long→float→double</p></blockquote><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符类型也是一个重要的基本数据类型，它可以表示计算机中的任意一个字符（包括中文、英文、标点等一切可以显示出来的字符）</p><ul><li>char 字符型（16个bit，也就是2字节，它不带符号）范围是0 ~ 65535</li></ul><p>可以看到char类型依然存储的是数字，那么它是如何表示每一个字符的呢？实际上每个数字在计算机中都会对应一个字符，首先我们需要介绍ASCII码：</p><p><img src="/../img/images/Z7AiBPNO6ylML4z.png"></p><p>比如我们的英文字母<code>A</code>要展示出来，那就是一个字符的形式，而其对应的ASCII码值为65，所以说当char为65时，打印出来的结果就是大写的字母A了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">65</span>;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230714161916691.png"></p><p>这里的字符表里面不就128个字符吗，那<code>char</code>干嘛要两个字节的空间来存放呢？我们发现表中的字符远远没有我们所需要的那么多，这里只包含了一些基础的字符，中文呢？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文。这时，我们就需要扩展字符集了。</p><blockquote><p>我们可以使用两个甚至多个字节来表示一个中文字符，这样我们能够表示的数量就大大增加了，GB2132方案规定当连续出现两个大于127的字节时（注意不考虑符号位，此时相当于是第一个bit位一直为1了），表示这是一个中文字符（所以为什么常常有人说一个英文字符占一字节，一个中文字符占两个字节），这样我们就可以表示出超过7000种字符了，不仅仅是中文，甚至中文标点、数学符号等，都可以被正确的表示出来。</p><p>不过这样能够表示的内容还是不太够，除了那些常见的汉字之外，还有很多的生僻字，比如龘、錕、釿、拷这类的汉字，后来干脆直接只要第一个字节大于127，就表示这是一个汉字的开始，无论下一个字节是什么内容（甚至原来的128个字符也被编到新的表中），这就是Windows至今一直在使用的默认GBK编码格式。</p><p>虽然这种编码方式能够很好的解决中文无法表示的问题，但是由于全球还有很多很多的国家以及很多很多种语言，所以我们的最终目标是能够创造一种可以表示全球所有字符的编码方式，整个世界都使用同一种编码格式，这样就可以同时表示全球的语言了。所以这时就出现了一个叫做ISO的（国际标准化组织）组织，来定义一套编码方案来解决所有国家的编码问题，这个新的编码方案就叫做Unicode（准确的说应该是规定的字符集，包含了几乎全世界所有语言的字符），规定每个字符必须使用两个字节，即用16个bit位来表示所有的字符（也就是说原来的那128个字符也要强行用两位来表示）</p><p>但是这样的话实际上是很浪费资源的，因为这样很多字符都不会用到两字节来保存，肯定不能直接就这样去表示，这会导致某些字符浪费了很多空间，我们需要一个更加好用的具体的字符编码方式。所以最后就有了UTF-8编码格式（它是Unicode字符集的一个编码规则），区分每个字符的开始是根据字符的高位字节来区分的，比如用一个字节表示的字符，第一个字节高位以“0”开头；用两个字节表示的字符，第一个字节的高位为以“110”开头，后面一个字节以“10开头”；用三个字节表示的字符，第一个字节以“1110”开头，后面俩字节以“10”开头；用四个字节表示的字符，第一个字节以“11110”开头，后面的三个字节以“10”开头：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">10000011</span> <span class="hljs-number">10000110</span>    <span class="hljs-comment">//这就是一个连续出现都大于127的字节（注意这里是不考虑符号位的）</span><br></code></pre></td></tr></table></figure><p>所以如果我们的程序需要表示多种语言，最好采用UTF-8编码格式，随着更多的字符加入，实际上两个字节也装不下了，可能需要3个甚至4个字节才能表示某些符号，后来就有了UTF-16编码格式，Java在运行时采用的就是UTF-16，几乎全世界的语言用到的字符都可以表示出来。</p></blockquote><table><thead><tr><th>Unicode符号范围（十六进制）</th><th>UTF-8编码方式(二进制)</th></tr></thead><tbody><tr><td>0000 0000 ~ 0000 007F</td><td>0xxxxxxx</td></tr><tr><td>0000 0080 ~ 0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0000 0800 ~ 0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0001 0000 ~ 0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p><strong>注意：</strong>Unicode 是“字符集”，也就是有哪些字符，而UTF-8、UTF-16 是“编码规则”，也就是怎么对这些字符编码，怎么以二进制的形式保存，千万不要搞混了。</p><p>简而言之，char实际上需要两个字节才能表示更多种类的字符，所以，<code>char</code>类型可以直接表示一个中文字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;淦&#x27;</span>;   <span class="hljs-comment">//使用int类型接收字符类型常量值可以直接转换为对应的编码</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230714162221789.png"></p><p>Java程序在编译为<code>.class</code>文件之后，会采用UTF-8的编码格式，支持的字符也非常多，可以直接把变量名写成中文，依然可以编译通过：</p><p><img src="/../img/images/image-20230714162342998.png"></p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型是Java中的一个比较特殊的类型，它并不是存放数字的，而是状态，它有下面的两个状态：</p><ul><li>true - 真</li><li>false - 假</li></ul><p>布尔类型（boolean）只有<code>true</code>和<code>false</code>两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;   <span class="hljs-comment">//值只能是true或false</span><br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>给一个其他的值，无法编译通过：</p><p><img src="/../img/images/image-20230714162605303.png"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符可以直接给某个变量赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">666</span>;   <span class="hljs-comment">//使用等号进行赋值运算</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用规则为：</strong>赋值运算符的左边必须是一个可以赋值的目标，比如变量，右边可以是任意满足要求的值，包括变量。</p><p>当然，赋值运算符并不只是单纯的赋值，它是有结果的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a = <span class="hljs-number">777</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当出现连续使用赋值运算符时，按照从右往左的顺序进行计算，首先是<code>a = 777</code>，计算完成后，a的值就变成了777，计算完成后，会得到计算结果（赋值运算的计算结果就是赋的值本身，就像1 + 1的结果是2一样，a &#x3D; 1的结果就是1）此时继续进行赋值计算，那么b就被赋值为<code>a = 777</code>的计算结果，同样的也是 777 了。</p><p>所以，使用连等可以将一连串变量都赋值为最右边的值。</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到a赋值为1+1的结果，所以说最后a就是2了。</p><p>当然变量也是可以参与到算术运算中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a - <span class="hljs-number">10</span>;<br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>不同类型之间也可以进行运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-type">short</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;   <br>      <span class="hljs-comment">//不同类型的整数一起运算，小类型需要转换为大类型，short、byte、char一律转换为int再进行计算（无论算式中有无int，都需要转换），结果也是int；如果算式中出现了long类型，那么全部都需要转换到long类型再进行计算，结果也是long，反正就是依大的来</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为运算时会发生隐式类型转换，所以说这里b自动转换为了int类型进行计算，所以说最后得到结果也一定是转换后的类型：</p><p><img src="/../img/images/image-20230714165020791.png"></p><p>因为小数表示范围更广，所以说整数会被转换为小数再进行计算，而最后的结果也肯定是小数了。</p><p><img src="/../img/images/image-20230714165050944.png"></p><p>也可以将加减号作为正负符号使用，让a变成自己的相反数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    a = -a;   <span class="hljs-comment">//减号此时作为负号运算符在使用，会将右边紧跟的目标变成相反数</span><br>    System.out.println(a);   <span class="hljs-comment">//这里就会得到-10了</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="加法字符串拼接"><a href="#加法字符串拼接" class="headerlink" title="加法字符串拼接"></a>加法字符串拼接</h4><p>注意加法支持对字符串的拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;伞兵&quot;</span> + <span class="hljs-string">&quot;lbw&quot;</span>;   <span class="hljs-comment">//可以使用加号来拼接两个字符串</span><br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后这个字符串就变成了拼接后的结果了：</p><p><img src="/../img/images/image-20230714165350940.png"></p><p>字符串不仅可以跟字符串拼接，也可以跟基本数据类型拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;伞兵&quot;</span> + <span class="hljs-literal">true</span> + <span class="hljs-number">1.5</span> + <span class="hljs-string">&#x27;A&#x27;</span>;<br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就可以得到对应的结果了：</p><p><img src="/../img/images/image-20230714165415953.png"></p><p>当然，除了加减法之外乘除法也是支持的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>, b = <span class="hljs-number">2</span>;<br>    System.out.println(a * b);   <span class="hljs-comment">//乘法使用*表示乘号</span><br>      System.out.println(a / b);   <span class="hljs-comment">//除法就是一个/表示除号</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，两个整数在进行除法运算时，得到的结果也是整数（会直接砍掉小数部分，注意不是四舍五入）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>, b = <span class="hljs-number">5</span>;<br>    System.out.println(a / b);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是两个int类型的值进行的除法运算，正常情况下8除以5应该得到1.6，但是由于结果也是整数，所以说最后小数部分被丢弃：</p><p><img src="/../img/images/image-20230714165447373.png"></p><p>但是如果是两个小数一起计算的话，因为结果也是小数，所以说就可以准确得到结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8.0</span>, b = <span class="hljs-number">5.0</span>;<br>    System.out.println(a / b);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/images/image-20230714165532619.png"></p><p>同样的，整数和小数一起计算，由于所有的整数范围都比小数小，根据我们上一部分介绍的转换规则，整数和小数一起计算时，所有的整数都会变成小数参与运算，所以说最后的结果也就是小数了，同样可以得到正确的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8.0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    System.out.println(a / b);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="整数计算出小数"><a href="#整数计算出小数" class="headerlink" title="整数计算出小数"></a>整数计算出小数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>, b = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a;   <span class="hljs-comment">//我们可以将其先隐式转换为小数类型，再那转换后的小数变量去参与计算</span><br>    System.out.println(c / b);   <span class="hljs-comment">//同样可以得到正确结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在下一节，我们将介绍强制类型转换，通过使用强制类型转换，我们可以更轻松地让整数计算出小数的结果。</p><p>除了最基本的加减乘除操作，可以进行取模操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    System.out.println(a % <span class="hljs-number">3</span>);   <span class="hljs-comment">//比如这里对a进行取模操作，实际上就是计算除以3的余数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如上面的是 10 % 3 得到的结果就是10除以3最后的余数1，取模操作也是非常好用的。</p><p>比如我们查看某个数是否为双数，只需要将其对2进行取模操作即可，因为如果是双数一定是可以整除的，如果是单数一定会余1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-number">17</span> % <span class="hljs-number">2</span>);   <span class="hljs-comment">//17不是双数，所以说最后会得到1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，运算符之间是有优先级之分的，比如乘除法优先级高于加减法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-number">10</span> + <span class="hljs-number">3</span> * <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a = <span class="hljs-number">8</span> * -a + <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1. 正负号优先级最高，所有首先计算的是-a，得到-10</span><br><span class="hljs-comment">        2. 其次是乘除号优先级更高，所以说这里计算 8 * -10，得到 -80</span><br><span class="hljs-comment">        3. 然后是加减法，-80 + 10 = -70</span><br><span class="hljs-comment">        4. 最后是赋值运算，因为等号运算符从右往左结合，先算a = -70的结果就是 -70</span><br><span class="hljs-comment">        5. 最后b就是 -70</span><br><span class="hljs-comment">     */</span><br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="括号运算符"><a href="#括号运算符" class="headerlink" title="括号运算符"></a>括号运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (a = <span class="hljs-number">8</span>) * (-a + <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1. 括号的优先级是最高的，我们需要先计算括号中的内容，如果存在多个括号，就从左往右计算</span><br><span class="hljs-comment">        2. 首先是 a = 8，计算完成之后a变成8，并且运算结果也为8</span><br><span class="hljs-comment">        3. 然后是后面的加法，-a就是-8，加上10就是2</span><br><span class="hljs-comment">        4. 最后才是乘法，左边此时是8，右边是2，最后结果为16</span><br><span class="hljs-comment">     */</span><br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>在嵌套的情况下，会优先计算最内层括号中的算式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-number">2</span> + (<span class="hljs-number">3</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">3</span>) * <span class="hljs-number">2</span>;<br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p>想要对一个变量进行这样的自增操作时，可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    a = a + <span class="hljs-number">1</span>;    <span class="hljs-comment">//让a等于a本身+1，相当于自增了1</span><br>    System.out.println(a);   <span class="hljs-comment">//得到9</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用自增自减运算符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    a++;   <span class="hljs-comment">//自增运算符就是两个加号连在一起，效果跟上面是一样的，a都会自增1</span><br>      a--;  <br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>自增自减运算符可以放到操作数的前后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    ++a;   <span class="hljs-comment">//自增运算符在前在后最终效果都是让a自增1，是一样的</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>自增自减操作同样是有结果的，注意，这两种方式自增操作的结果不一样，我们来看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a++;   <span class="hljs-comment">//先出结果，再自增</span><br>    System.out.println(b);  <span class="hljs-comment">//b得到的是a自增前的值</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ++a;   <span class="hljs-comment">//先自增，再出结果</span><br>    System.out.println(b);   <span class="hljs-comment">//b得到的是a自增之后的结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>自增自减运算符的优先级与正负号等价比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> -a++ + ++a; <br>      <span class="hljs-comment">//我们首先来看前面的a，因为正负号和自增是同一个优先级，结合性是从右往左，所以说先计算a++</span><br>      <span class="hljs-comment">//a++的结果还是8，然后是负号，得到-8</span><br>      <span class="hljs-comment">//接着是后面的a，因为此时a已经经过前面变成9了，所以说++a就是先自增，再得到10</span><br>      <span class="hljs-comment">//最后得到的结果为 -8 + 10 = 2</span><br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>以其他数进行自增：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    a += <span class="hljs-number">4</span>;   <span class="hljs-comment">//加号和等号连在一起，与a = a + 4效果完全一样</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>全部算术运算符都是支持这种缩写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    a *= <span class="hljs-number">9</span>;   <span class="hljs-comment">//跟 a = a * 9 等价</span><br>    System.out.println(a);   <span class="hljs-comment">//得到72</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符包括：&amp; | ^ ~</p><h4 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h4><p>按位与&amp;，比如下面的两个数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>, b = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a &amp; b;    <span class="hljs-comment">//进行按位与运算</span><br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>按位与实际上就是让这两个数每一位都进行比较，如果这一位两个数都是1，那么结果就是1，否则就是0：</p><ul><li>a &#x3D; 9 &#x3D; 1001</li><li>b &#x3D; 3 &#x3D; 0011</li><li>c &#x3D; 1 &#x3D; 0001（因为只有最后一位，两个数都是1，所以说结果最后一位是1，其他都是0）</li></ul><h4 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h4><p>同样的，按位或，其实就是只要任意一个为1（不能同时为0）那么结果就是1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>, b = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a | b;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>a &#x3D; 9 &#x3D; 1001</li><li>b &#x3D; 3 &#x3D; 0011</li><li>c &#x3D;11&#x3D; 1011（只要上下有一个是1或者都是1，那结果就是1）</li></ul><h4 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h4><p>按位异或符号很多小伙伴会以为是乘方运算，但是Java中并没有乘方运算符，<code>^</code>是按位异或运算符，不要记错了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>, b = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a ^ b;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>异或的意思就是只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况：</p><ul><li>a &#x3D; 9 &#x3D; 1001</li><li>b &#x3D; 3 &#x3D; 0011</li><li>c &#x3D;10&#x3D; 1010（从左往右第二位、第四位要么两个都是0，要么两个都是1，所以说结果为0）</li></ul><h4 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h4><p>按位取反操作跟前面的正负号一样，只操作一个数，最好理解，如果这一位上是1，变成0，如果是0，变成1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ~<span class="hljs-number">127</span>;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>127 &#x3D; 01111111</li><li>-128 &#x3D; 10000000</li></ul><p>所以说计算的结果就是-128了。</p><h4 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;    <span class="hljs-comment">//两个连续的小于符号，表示左移运算</span><br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>1 &#x3D; 00000001</li><li>4 &#x3D; 00000100（左移两位之后，1跑到前面去了，尾部使用<strong>0</strong>填充，此时就是4）</li></ul><p>我们发现，左移操作每进行一次，结果就会x2，所以说，除了直接使用<code>*</code>进行乘2的运算之外，我们也可以使用左移操作来完成。</p><p>同样的，右移操作就是向右移动每一位咯：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span> &gt;&gt; <span class="hljs-number">2</span>;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>8 &#x3D; 00001000</li><li>2 &#x3D; 00000010（右移两位之后，1跑到后面去了，头部使用<strong>符号位数字</strong>填充，此时变成2）</li></ul><p>跟上面一样，右移操作可以快速进行除以2的计算。</p><p>对于负数来说，左移和右移操作不会改变其符号位上的数字，符号位不受位移操作影响：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">1</span>;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>-4 &#x3D; 11111100</li><li>-2 &#x3D; 11111110（前面这一长串1都被推到后面一位了，因为是负数，头部需要使用<strong>符号位数字</strong>来进行填充）</li></ul><p>来总结一下：</p><ul><li><strong>左移操作&lt;&lt;：</strong>高位直接丢弃，低位补0</li><li><strong>右移操作&gt;&gt;：</strong>低位直接丢弃，符号位是什么高位补什么</li></ul><p>也可以使用考虑符号位的右移操作，一旦考虑符号位，那么符号会被移动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;   <span class="hljs-comment">//正常的右移操作，高位补1，所以说移了还是-1</span><br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &gt;&gt;&gt; <span class="hljs-number">1</span>;   <span class="hljs-comment">//无符号右移是三个大于符号连在一起，移动会直接考虑符号位</span><br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>比如：</p><ul><li>-1 &#x3D; 11111111 11111111 11111111 11111111</li><li>右移： 01111111 11111111 11111111 11111111（无符号右移使用0填充高位）</li></ul><p>此时得到的结果就是正数的最大值 2147483647 了，注意，不存在无符号左移。</p><p>位移操作也可以缩写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    c = c &lt;&lt; <span class="hljs-number">2</span>;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以缩写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    c &lt;&lt;= <span class="hljs-number">2</span>;    <span class="hljs-comment">//直接运算符连上等号即可，跟上面是一样的</span><br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>判断两个变量谁更大，我们可以使用关系运算符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a &gt; b;   <span class="hljs-comment">//进行判断，如果a &gt; b那么就会得到true，否则会得到false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关系判断的结果只可能是真或是假，所以说得到的结果是一个<code>boolean</code>类型的值。</p><p>关系判断运算符包括：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&gt;   大于<br>&lt;   小于<br><span class="hljs-section">==  等于（注意是两个等号连在一起，不是一个等号，使用时不要搞混了）</span><br>!=  不等于<br>&gt;=  大于等于<br>&lt;=  小于等于<br><br></code></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&amp;&amp;     与运算，要求两边同时为<span class="hljs-literal">true</span>才能返回<span class="hljs-literal">true</span><br>||     或运算，要求两边至少要有一个为<span class="hljs-literal">true</span>才能返回<span class="hljs-literal">true</span><br>!      非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转<br></code></pre></td></tr></table></figure><p>三元运算符可以根据判断条件，返回不同的结果，比如我们想要判断：</p><ul><li>当a &gt; 10时，给b赋值’A’</li><li>当a &lt;&#x3D; 10时，给b赋值’B’</li></ul><p>我们就可以使用三元运算符来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a &gt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;A&#x27;</span> : <span class="hljs-string">&#x27;B&#x27;</span>;   <span class="hljs-comment">//三元运算符需要三个内容，第一个是判断语句，第二个是满足判断语句的值，第三个是不满足判断语句的值</span><br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>三元运算符：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">判断语句 ? 结果<span class="hljs-number">1</span> : 结果2<br></code></pre></td></tr></table></figure><p>因此，上面的判断为假，所以说返回的是结果2，那么最后b得到的就是<code>B</code>这个字符了。</p><table><thead><tr><th>优先级</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>1</td><td>( )</td><td>从左向右</td></tr><tr><td>2</td><td>~ - + (强制类型转换) ++ –</td><td>从右向左</td></tr><tr><td>3</td><td>* &#x2F; %</td><td>从左向右</td></tr><tr><td>4</td><td>+ -</td><td>从左向右</td></tr><tr><td>5</td><td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td><td>从左向右</td></tr><tr><td>6</td><td>&gt; &lt; &gt;&#x3D; &gt;&#x3D;</td><td>从左向右</td></tr><tr><td>7</td><td>&#x3D;&#x3D; !&#x3D;</td><td>从左向右</td></tr><tr><td>8</td><td>&amp;</td><td>从左向右</td></tr><tr><td>9</td><td>^</td><td>从左向右</td></tr><tr><td>10</td><td>|</td><td>从左向右</td></tr><tr><td>11</td><td>&amp;&amp;</td><td>从左向右</td></tr><tr><td>12</td><td>||</td><td>从左向右</td></tr><tr><td>13</td><td>? :</td><td>从右向左</td></tr><tr><td>14</td><td>&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &amp;&#x3D; |&#x3D; ^&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &gt;&gt;&gt;&#x3D;</td><td>从右向左</td></tr></tbody></table><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>某些时候，希望进行判断，只有在条件为真时，才执行某些代码</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (条件判断) 判断成功执行的代码<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">15</span>)    <span class="hljs-comment">//只有当a判断等于15时，才会执行下面的打印语句</span><br>          System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>      System.out.println(<span class="hljs-string">&quot;我是外层&quot;</span>);   <span class="hljs-comment">//if只会对紧跟着的一行代码生效，后续的内容无效</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>if</code>会进行判断，只有判断成功时才会执行紧跟着的语句，否则会直接跳过，注意，如果我们想要在if中执行多行代码，需要使用代码块将这些代码囊括起来（实际上代码块就是将多条语句复合到一起）所以说，我们以后使用if时，如果分支中有多行代码需要执行，就需要添加花括号，如果只有一行代码，花括号可以直接省略，包括我们后面会讲到的else、while、for语句都是这样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">10</span>) &#123;    <span class="hljs-comment">//只有判断成功时，才会执行下面的代码块中内容，否则直接跳过</span><br>        System.out.println(<span class="hljs-string">&quot;a大于10&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;a的值为：&quot;</span>+a);<br>    &#125;<br>      System.out.println(<span class="hljs-string">&quot;我是外层&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>if-else</code>语句就像两个分支，跟据不同的判断情况从而决定下一步该做什么，这跟我们之前认识的三元运算符性质比较类似。</p><p>那如果此时我们需要判断多个分支呢？比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用<code>else-if</code>来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span>  <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(score &gt;= <span class="hljs-number">90</span>)    <span class="hljs-comment">//90分以上才是优秀</span><br>        System.out.println(<span class="hljs-string">&quot;优秀&quot;</span>);<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">70</span>)    <span class="hljs-comment">//当上一级if判断失败时，会继续判断这一级</span><br>        System.out.println(<span class="hljs-string">&quot;良好&quot;</span>);<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">60</span>)<br>        System.out.println(<span class="hljs-string">&quot;及格&quot;</span>);<br>     <span class="hljs-keyword">else</span>    <span class="hljs-comment">//当之前所有的if都判断失败时，才会进入到最后的else语句中</span><br>        System.out.println(<span class="hljs-string">&quot;不及格&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，<code>if</code>分支语句还支持嵌套使用，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span>  <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(score &lt; <span class="hljs-number">60</span>) &#123;   <span class="hljs-comment">//先判断不及格</span><br>        <span class="hljs-keyword">if</span>(score &gt; <span class="hljs-number">30</span>)    <span class="hljs-comment">//在内层再嵌套一个if语句进行进一步的判断</span><br>            System.out.println(<span class="hljs-string">&quot;学习C++&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            System.out.println(<span class="hljs-string">&quot;学习Java&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>也可以使用<code>switch</code>语句来实现，它更适用于多分支的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (目标) &#123;   <span class="hljs-comment">//我们需要传入一个目标，比如变量，或是计算表达式等</span><br>  <span class="hljs-keyword">case</span> 匹配值:    <span class="hljs-comment">//如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码</span><br>    代码...<br>    <span class="hljs-keyword">break</span>;    <span class="hljs-comment">//代码执行结束后需要使用break来结束，否则会溜到下一个case继续执行代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>要根据学生的等级进行分班，学生有ABC三个等级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-keyword">switch</span> (c) &#123;  <span class="hljs-comment">//这里目标就是变量c</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:    <span class="hljs-comment">//分别指定ABC三个匹配值，并且执行不同的代码</span><br>            System.out.println(<span class="hljs-string">&quot;去尖子班！准备冲刺985大学！&quot;</span>);<br>            <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//执行完之后一定记得break，否则会继续向下执行下一个case中的代码</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>            System.out.println(<span class="hljs-string">&quot;去平行班！准备冲刺一本！&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<br>            System.out.println(<span class="hljs-string">&quot;去职高深造。&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>switch</code>可以精准匹配某个值，但是它不能进行范围判断，比如要判断分数段，这时用switch就很鸡肋了。</p><p>当然除了精准匹配之外，其他的情况我们可以用default来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (目标) &#123;<br>    <span class="hljs-keyword">case</span>: ...<br>    <span class="hljs-keyword">default</span>:<br>            其他情况下执行的代码<br>&#125;<br></code></pre></td></tr></table></figure><p>还是以刚才那个例子为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>            System.out.println(<span class="hljs-string">&quot;去尖子班！&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>            System.out.println(<span class="hljs-string">&quot;去平行班！&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<br>            System.out.println(<span class="hljs-string">&quot;去差生班！&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:   <span class="hljs-comment">//其他情况一律就是下面的代码了</span><br>            System.out.println(<span class="hljs-string">&quot;去读职高，分流&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然switch中可以继续嵌套其他的流程控制语句，比如if：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;    <span class="hljs-comment">//嵌套一个if语句</span><br>                System.out.println(<span class="hljs-string">&quot;去尖子班！&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>            System.out.println(<span class="hljs-string">&quot;去平行班！&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>在某些时候，可能需要批量执行某些代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);   <span class="hljs-comment">//把这句话给我打印三遍</span><br>    System.out.println(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>可以使用for循环语句来多次执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (表达式<span class="hljs-number">1</span>;表达式<span class="hljs-number">2</span>;表达式<span class="hljs-number">3</span>) 循环体;<br></code></pre></td></tr></table></figure><p>介绍一下详细规则：</p><ul><li>表达式1：在循环开始时仅执行一次。</li><li>表达式2：每次循环开始前会执行一次，要求为判断语句，用于判断是否可以结束循环，若结果为真，那么继续循环，否则结束循环。</li><li>表达式3：每次循环完成后会执行一次。</li><li>循环体：每次循环都会执行一次循环体。</li></ul><p>一个标准的for循环语句写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//比如我们希望让刚刚的打印执行3次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)    <span class="hljs-comment">//这里我们在for语句中定义一个变量i，然后每一轮i都会自增，直到变成3为止</span><br>        System.out.println(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);   <span class="hljs-comment">//这样，就会执行三轮循环，每轮循环都会执行紧跟着的这一句打印</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以在循环过程中提前终止或是加速循环的进行，需要认识两个新的关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">//比如我们希望当i等于1时跳过这一轮，不执行后面的打印</span><br>        System.out.println(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;当前i的值为：&quot;</span>+i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用<code>continue</code>关键字来跳过本轮循环，直接开启下一轮。这里的跳过是指，循环体中，无论后面有没有未执行的代码，一律不执行，比如上面的判断如果成功，那么将执行<code>continue</code>进行跳过，虽然后面还有打印语句，但是不会再去执行了，而是直接结束当前循环，开启下一轮。</p><p>在某些情况下，可能希望提前结束循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//我们希望当i等于1时提前结束</span><br>    System.out.println(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;当前i的值为：&quot;</span>+i);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用<code>break</code>关键字来提前终止整个循环，和上面一样，本轮循环中无论后续还有没有未执行的代码，都不会执行了，而是直接结束整个循环，跳出到循环外部。</p><p>虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; ++j) &#123;<br>        <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">continue</span>;    <span class="hljs-comment">//当i == j时加速循环</span><br>        System.out.println(i+<span class="hljs-string">&quot;, &quot;</span>+j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>continue</code>加速的对象并不是外层的for，而是离它最近的内层for循环，<code>break</code>也是同样的规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; ++j) &#123;<br>        <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">break</span>;    <span class="hljs-comment">//当i == j时终止循环</span><br>        System.out.println(i+<span class="hljs-string">&quot;, &quot;</span>+j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，要是我们就是想要终止或者是加速外层循环呢？我们可以为循环语句打上标记：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">outer: <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;   <span class="hljs-comment">//在循环语句前，添加 标签: 来进行标记</span><br>    inner: <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; ++j) &#123;<br>        <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">break</span> outer;    <span class="hljs-comment">//break后紧跟要结束的循环标记，当i == j时终止外层循环</span><br>        System.out.println(i+<span class="hljs-string">&quot;, &quot;</span>+j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个代码块中存在多个循环，那么直接对当前代码块的标记执行<code>break</code>时会直接跳出整个代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">outer: &#123;    <span class="hljs-comment">//直接对整个代码块打标签</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">7</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Test&quot;</span>);<br>            <span class="hljs-keyword">break</span> outer;   <span class="hljs-comment">//执行break时，会直接跳出整个代码块，而不是第一个循环</span><br>        &#125;<br>    &#125;<br><br>    System.out.println(<span class="hljs-string">&quot;？？？&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(循环条件) 循环体;<br></code></pre></td></tr></table></figure><p>相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当<code>i</code>大于10时需要结束循环，但是<code>i</code>在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;   <span class="hljs-comment">//比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确</span><br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//现在唯一知道的是循环条件，只要大于0那么就可以继续除</span><br>        System.out.println(i);<br>        i /= <span class="hljs-number">2</span>;   <span class="hljs-comment">//每次循环都除以2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这种情况就非常适合使用while循环。</p><p>和for循环一样，while也支持使用break和continue来进行循环的控制，以及嵌套使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br>        System.out.println(i);<br>        i /= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以反转循环判断的时机，可以先执行循环内容，然后再做循环条件判断，这里要用到<code>do-while</code>语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确</span><br>    <span class="hljs-keyword">do</span> &#123;  <span class="hljs-comment">//无论满不满足循环条件，先执行循环体里面的内容</span><br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>        i++;<br>    &#125; <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>);   <span class="hljs-comment">//再做判断，如果判断成功，开启下一轮循环，否则结束</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML5</title>
    <link href="/2022/09/15/HTML5/"/>
    <url>/2022/09/15/HTML5/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><blockquote><p><code>HTML</code>全称：<code>HyperText Markup Language</code></p></blockquote><h3 id="HTML5简介"><a href="#HTML5简介" class="headerlink" title="HTML5简介"></a>HTML5简介</h3><p><strong>简单的HTML5文档</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>Hello World!<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>HTML标签</strong></p><ul><li>&#96;&#96;&#96;html<br>&lt;标签&gt;内容&lt;&#x2F;标签&gt;<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>**HTML标签属性**<br><br>- ```html<br>  <span class="hljs-tag">&lt;<span class="hljs-name">标签</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">标签</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2022/09/15/Spring/"/>
    <url>/2022/09/15/Spring/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-Spring-Framework"><a href="#Spring-Spring-Framework" class="headerlink" title="Spring(Spring Framework)"></a>Spring(Spring Framework)</h2><p><strong>Spring是一个使用Java语言编写的轻量级开源框架，解决了项目的一些通用问题，例如依赖注入(DI)、切面织入(AOP)等，同时还提供了项目中各种技术的一站式的解决、整合方案。</strong></p><span id="more"></span><blockquote><p>Spring Framework下载列表：</p><p><a href="https://spring.io/projects/spring-framework">https://spring.io/projects/spring-framework</a></p></blockquote><h3 id="Spring优势"><a href="#Spring优势" class="headerlink" title="Spring优势"></a>Spring优势</h3><ul><li><p>容器性质，方便解耦，简化开发（<strong>核心</strong>）</p><ul><li>Spring提供的IOC容器，可以将对象之间的依赖关系交由给Spring容器进行控制，避免硬编码所造成的过度程序耦合。</li></ul></li><li><p>AOP编程的支持（<strong>核心</strong>）</p><ul><li>通过Spirng的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付</li></ul></li><li><p>声明式事务的支持</p><ul><li>通过声明式方式对事务进行灵活的管理，提高开发效率和质量</li></ul></li><li><p>集成各种优秀框架</p></li><li><p>降低JavaEE API的使用难度</p><ul><li>Spring对Java API 进行了封装，使得这些API降低了使用难度</li></ul></li></ul><h3 id="Spring模块"><a href="#Spring模块" class="headerlink" title="Spring模块"></a>Spring模块</h3><p>Spring-framework 框架是一个分层架构，它由大约20个模块组成，如图：</p><p><img src="/../img/images/Spring-Framework%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>这些模块分为Core Container，Date Access&#x2F;Integration、Web、AOP(Aspect Oriented Programming)、Instrumentation和Test</p><ol><li><p><strong>Core Container，核心容器</strong></p><ul><li><p>Core Container包含有Core、Beans、Context和Expression Language模块</p></li><li><p>Core和Beans模块：框架的基础部分，提供反转控制（IOC）和依赖注入（DI）特性。</p></li><li><p>Context模块：构建于Core和Beans模块基础之上，提供了对国际化、事件传播、资源加载和对Context的透明创建的支持。ApplicationContext接口是Context模块的关键。</p></li><li><p>Expression Language模块：Expression Language模块提供了一个强大的表达式语言用于在运行时查询和操纵对象。</p></li></ul></li><li><p><strong>Data Access&#x2F;Integration，数据访问&#x2F;集成部分</strong></p><ul><li>Data Access&#x2F;Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块</li><li>JDBC模块：该模块提供了一个JDBC抽象层，它可以消除冗长的JDBC编码和解析数据库厂商特有的错误代码。</li><li>ORM模块：该模块为流行的对象-关系映射API——JPA、JDO、Hibernate、Mybatis等提供了一个交互层。利用ORM封装包，可以混合使用所有Spring提供的特性进行O&#x2F;R映射。如前边提到的简单声明性事物管理。</li><li>OXM模块：该模块提供了一个对Object&#x2F;XML映射实现的抽象层，Object&#x2F;XML映射实现包括JAXB、Castor、XMLBeans、JiBX和XStream。</li><li>JMS模块：JMS(Java Messaging Service)模块主要包含了一些制造和消费消息的特性。</li><li>Transaction模块：该模块支持编程和声明性的事物管理，这些事物类必须实现特定的接口，并且对所有的POJO都适用。</li></ul></li><li><p><strong>Web</strong></p><ul><li>Web层包含了Web、Servlet、WebSocket、Portlet模块</li><li>Web模块：该模块提供了基础的面向web的集成特性。例如多文件上传、使用servlet listeners初始化IoC容器以及一个面向web的应用上下文。它还包含Spring远程支持中web相关部分。</li><li>Servlet模块：该模块包含Spring的model-view-controller（MVC）实现。Spring的MVC框架使得模型范围内的代码和web forms之间能够清楚的分离开来，并与Spring框架的其他特性集成在一起。</li><li>WebSocket模块：该模块提供了对WebSocket的支持。</li><li>Portlet模块：提供了用于portlet环境的MVC的实现，Portlet是和Servlet类似的一种web技术。</li></ul></li><li><p><strong>AOP和Instrumentation</strong></p><ul><li>AOP模块：提供了一个符合AOP联盟标准的面向切面编程的实现，它让你可以定义方法拦截器和切点，从而将逻辑代码分开，降低它们之间的耦合性。</li><li>Aspects模块：提供了对AspectJ的集成支持，Spring框架的AOP功能是使用AspectJ框架来实现的。</li><li>Instrumentation模块提供了class instrumentation支持和classloader实现，使得可以在特定的应用服务器上使用。</li></ul></li><li><p><strong>Test</strong></p><ul><li>Test模块：支持使用JUnit和TestNG对Spring组件进行测试</li></ul></li></ol><h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>我们之前使用的三层架构，在一定程度上能进行解耦，但也带来一个新的问题</p><ul><li>web层调用service层，要在web层创建service层的对象，然后调用方法</li><li>service层调用dao层，要在service层创建dao层的对象，然后调用方法</li></ul><p><strong>Web层依赖Service层的实现，Service层依赖于Dao层的实现，而且需要我们去手动创建并维护这些实现，随着项目逐渐扩展，这些创建和维护工作将会变得越来越复杂。</strong></p><p>为了更好的解耦，在启动项目的过程中，提前做好以下工作：</p><ul><li>创建一个容器（例如一个Map集合）</li><li>把项目中需要的对象提前创建好，并且存入该容器</li><li>每个模块需要用到对象，提前给该模块提供</li></ul><p><img src="/../img/images/Spring%E5%AE%B9%E5%99%A8%E9%A1%B9%E7%9B%AE%E5%9B%BE.png" alt="Spring容器项目图"></p><blockquote><p>Spring IOC就是一个类似这样的容器</p></blockquote><h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h4><p>**IOC(Inverse of Control)**控制反转，将对象的创建和依赖关系反转给Spring容器，程序本身不进行维护。</p><p>Spring官方文档中给结构图如下：</p><p><img src="/../img/images/Spring%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Spring官方文档结构图"></p><blockquote><p>注意，原来由我们自己手动创建并维护的对象，现在都可以交给Spring的IOC容器去进行管理维护</p></blockquote><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><ol><li>准备Spring开发的jar包</li><li>将核心容器jar包以及辅助包导入项目lib目录下</li><li>创建pojo类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.ioc;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Husband</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br>&#125;<br><span class="hljs-comment">//Lombok中的Data注解，该类编译后会自动生成对应的Get/Set方法以及toString等方法</span><br></code></pre></td></tr></table></figure><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>1、在src下面创建配置文件applicationContext.xml</p><p>2、xml添加头部声明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">              https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、在配置文件中添加需要被Spring容器管理的资源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">              https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--bean标签的作用：用于配置让Spring容器创建对象</span><br><span class="hljs-comment">class : 要创建对象的全限定类名</span><br><span class="hljs-comment">name: 该对象在容器中的名字</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;husband&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.briup.ioc.Husband&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>SpringIOC容器管理的对象，称为bean，所以需要使用bean标签进行配置</p></blockquote><ul><li>id：一个bean的唯一标识，命名格式必须符合XML ID属性的命名规范</li><li>name：可以用特殊字符，并且一个bean可以用多个名称，例如ame&#x3D;”bean1，bean2，bean3”</li><li>如果没有id，则name的第一个名称默认为id</li><li>如果一个bean标签未指定id、name属性，则Spring容器会给起一个的id，值为其类全名</li><li>如果有多个bean标签未指定id、name属性，但class相同，则Spring容器会按照其出现的次序，分别给其指定id值为”类全名#1”，”类全名#2”</li></ul><p>4、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.test;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><span class="hljs-keyword">import</span> com.briup.ioc.Husband;<br><span class="hljs-meta">@SuppressWarnings(&quot;resource&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringIoCTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 1.解析配置文件,创建容器</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><span class="hljs-comment">// 2.根据配置的Id值,从容器中获取对象</span><br><span class="hljs-type">Husband</span> <span class="hljs-variable">hunsband</span> <span class="hljs-operator">=</span> (Husband) ac.getBean(<span class="hljs-string">&quot;husband&quot;</span>);<br>System.out.println(hunsband);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h5><p>容器顶层接口时BeanFactory</p><p>BeanFactory 和 ApplicationContext 的区别</p><ul><li><p>BeanFactory是Spring容器的顶层接口，ApplicationContext是其子接口</p></li><li><p>ApplicationContext接口,它由BeanFactory接口派生而来，包含BeanFactory的所有功能</p></li><li><p>BeanFactory 创建容器时不会创建对象，当从容器里面获取对象时才会创建</p></li><li><p>ApplicationContext 创建容器时就会创建对象</p></li></ul><p><strong>ApplicationContext接口实现类</strong></p><p>1、ClassPathXmlApplication</p><p>从类的根路径下加载配置文件</p><p>2、FileSysytemXmlApplication</p><p>从磁盘路径加载配置文件，配置文件可以在磁盘任何位置</p><p>3、AnnotationConfigApplicationContext</p><p>用注解配置容器对象时，需要使用此类来创建Spring容器</p><h5 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h5><p>1、<bean>标签的作用</p><ul><li>用于配置让Spring容器创建对象</li><li>默认情况下它调用的事类中的无参构造函数（反射）</li></ul><p>2、<bean>标签的属性</p><ul><li>id 给容器中的对象提供一个唯一标识，用来获取对象</li><li>name 功能类似 id，命名要求没有 id 严格</li><li>class 指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数</li><li>scope 指定对象范围<ul><li>sigleton 默认值 单例</li><li>protoype 多例</li><li>request WEB项目中，Spring容器创建一个Bean对象，会将该对象存入request</li><li>session WEB项目中，Spring容器创建一个Bean对象，会将该对象存入session</li><li>golbal session 只有应用在基于portlet的Web应用程序中才有意义，它映射到portlet的global范围的session</li></ul></li><li>init-method：指定类的初始化方法名字</li><li>destory-method：指定类中销毁方法的名字</li><li>lazy-init：指定使用进行延迟加载， 默认值default为false</li></ul><h3 id="Spring-DI"><a href="#Spring-DI" class="headerlink" title="Spring DI"></a>Spring DI</h3><blockquote><p>DI（Denpendency Injection），依赖注入，SpringIOC容器中的核心操作，可以将对象需要的属性值自动注入</p></blockquote><h4 id="XML-1"><a href="#XML-1" class="headerlink" title="XML"></a>XML</h4><h5 id="set方法注入"><a href="#set方法注入" class="headerlink" title="set方法注入"></a>set方法注入</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--property 给属性采用set方法赋值</span><br><span class="hljs-comment">name : 属性名，调用该属性的set方法</span><br><span class="hljs-comment">value: 属性值，通过set方法赋值</span><br><span class="hljs-comment">ref: 属性是其他bean类型采用ref(字符串除外)</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hunsband&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.briup.ioc.Hunsband&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;tom&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;salary&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;now&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;now&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.util.Date&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h5><blockquote><p>需要有对应构造器</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">constructor-arg 让属性赋值采用构造函数赋值</span><br><span class="hljs-comment">index: 指定参数在构造函数中的索引位置</span><br><span class="hljs-comment">type: 指定参数在构造函数中的数据类型</span><br><span class="hljs-comment">name: 指定参数在构造函数中的名字</span><br><span class="hljs-comment">value: 具体的参数值</span><br><span class="hljs-comment">ref: 如果需要的数据为其他bean类型，使用ref</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;husband&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.briup.ioc.Husband&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mary&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;salary&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;now&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;now&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.util.Date&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>也可以用下标 index</p></blockquote><h5 id="名称空间注入"><a href="#名称空间注入" class="headerlink" title="名称空间注入"></a>名称空间注入</h5><p>xml文件的添加p名称空间的声明，这里p指的的是property</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;husband&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.briup.ioc.Husband&quot;</span> <span class="hljs-attr">p:id</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;lucy&quot;</span> <span class="hljs-attr">p:salary</span>=<span class="hljs-string">&quot;4000&quot;</span> <span class="hljs-attr">p:date-ref</span>=<span class="hljs-string">&quot;now&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;now&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.util.Date&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="集合属性注入"><a href="#集合属性注入" class="headerlink" title="集合属性注入"></a>集合属性注入</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;entity&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.briup.ioc.Entity&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 注入数组 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myStrs&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>AAA<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BBB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>CCC<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 注入List --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myList&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>DDD<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>EEE<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>FFF<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 注入Set --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mySet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>GGG<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>KKK<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>LLL<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 注入myMap --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myMap&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 俩种形式都可以注入 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;tom&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>20<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 注入Properties --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myProps&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>mary<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>POJO类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.ioc;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span>: kaf(bl)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>：</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Husband</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;1&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-meta">@Value(&quot;kaf&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@Value(&quot;1000&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Husband</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">   https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">   http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">   http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 配置要扫描的注解包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.kaf.ioc&quot;</span>&gt;</span>&lt;/context:componentscan&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringIocTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-type">Husband</span> <span class="hljs-variable">husband</span> <span class="hljs-operator">=</span> (Husband) ac.getBean(<span class="hljs-string">&quot;husband&quot;</span>);<br>        System.out.println(husband);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h4><p>Spring中常用的注解有以下几个：</p><ul><li><p>@Component</p><ul><li><p>作用：让spring容器来管理对象，相当于在xml中配置一个bean。</p></li><li><p>属性：</p><ul><li>​value: 指定bean的名字，如果不指定，默认为当前类名且首字母小写</li></ul></li></ul></li><li><p>@Controller , @Service , @Repository</p><ul><li><p>作用：功能与 @Component 作用一样，只不过其语义更加明确</p><ul><li><p>@Controller 一般作用于 表现层</p></li><li><p>@Service 一般作用于 业务层</p></li><li><p>@Repository 一般作用于 持久层</p></li></ul></li><li><p>属性：</p><ul><li>value : 指定bean的名字,如果不指定，默认为当前类名，且首字母小写</li></ul></li></ul></li><li><p>@Value</p><ul><li><p>作用：用于给属性注入基本数据，此注解中还支持SpEL</p></li><li><p>属性：</p><ul><li>value :具体的属性值</li></ul></li></ul></li><li><p>@Autowired</p><ul><li>作用：自动按照类型注入，使用注解注入属性时，set方法可以省略，该注解只能注入bean类型，当有多个相同类型时，将bean的名字作为要注入对象的属性名，也可以注入成功</li></ul></li><li><p>@Qualifier</p><ul><li><p>作用：在 @Autowired 注入的基础之上，再按照Bean的名字注入。在给属性注入数据时不能独立使用，必须和 @Autowired 一起使用</p></li><li><p>属性：</p><ul><li>value：指定bean的名字</li></ul></li></ul></li><li><p>@Resource</p><ul><li><p>作用：直接按照bean的id注入,只能注入bean类型</p></li><li><p>属性：</p><ul><li>name: bean的名字</li></ul></li></ul></li><li><p>@Scope</p><ul><li><p>作用：指定bean的作用范围</p></li><li><p>属性：</p><ul><li><p>value: 指定范围值</p></li><li><p>取值为： singleton , prototype , request , session , golbalsession</p></li></ul></li></ul></li><li><p>@PostConstruct</p><ul><li>作用：指定初始化方法</li></ul></li><li><p>@PreDestroy</p><ul><li>作用：指定销毁方法</li></ul></li></ul><h4 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h4><blockquote><p>可以去掉xml文件，全部使用注解的方式IOC和DI配置和操作，但是需要使用专门的容器类型：AnnotationConfigApplicationContext</p></blockquote><h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><h5 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h5><p>作用：</p><ul><li>用于指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解</li><li>可以使用AnnotaConfigApplicationContext(配置类.class)加载配置</li></ul><h5 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h5><p>作用：</p><ul><li>用于指定Spring在初始化容器时要扫描的包</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@Configuration</span></span><br><span class="hljs-comment">* 表示当前类是spring的一个配置类</span><br><span class="hljs-comment">* 相当于之前的xml，可以完成其对应的配置功能</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@ComponentScan</span>(&quot;com.briup.ioc&quot;)</span><br><span class="hljs-comment">* 扫描当前包和指定包下面的java类，发现其中spring注解</span><br><span class="hljs-comment">* 包含指定包下面的子包</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.briup.ioc&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h5><p>作用：</p><ul><li>该注解只能写在方法上，表明使用此方法创建一个对象，并且放入Spring容器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">* 一个<span class="hljs-doctag">@Bean</span>注解就相当于bean标签</span><br><span class="hljs-comment">* 方法的返回值对象会存储在Spring容器中</span><br><span class="hljs-comment">* 方法名就是该对象在容器中的唯一标识</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Teacher <span class="hljs-title function_">teacher</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h5><p>作用：</p><ul><li>用于加载.properties文件中的值，加载后可以使用@Value(“${key}”)的形式来获取</li></ul><h5 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h5><p>作用：</p><ul><li>用于导入其他配置类</li><li>被引入配置类，可以不用再写@Configuration注解，当然，写上也可以</li><li>一般项目中写了很多配置类的时候，可以再用一个总的配置类，这次配置类使用@Import去引入其他配置，将来容器只要读取这个一个总的配置类即可</li></ul><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><blockquote><p>代理模式是一种常见的设计模式，它提供间接对目标对象访问的方式，通过代理对象访问目标对象，从而在在目标对象现有的功能能上，增加额外的功能补充，实现扩展目标对象的功能</p></blockquote><p>代理模式主要包含三个角色：</p><ul><li><p>主题类角色</p><ul><li>可以是接口，也可以是抽象类，需要让目标对象和代理对象去实现或者继承，目的是为了让目标对象和代理对象具有相同的方法</li></ul></li><li><p>目标类角色</p><ul><li>它的对象就是目标对象，核心业务逻辑的具体执行者</li></ul></li><li><p>代理类角色</p><ul><li>它的对象就是代理对象，内部含有对真实目标对象的引用，负责对目标对象方法的调用，并且在调用前后进行预处理</li></ul></li></ul><h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><blockquote><p>静态代理是代理模式的实现方式之一，在程序运行前，手动创建代理类，从而实现对目标类中的方法进行增强。</p></blockquote><p><strong>公共接口Singer：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Singer</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>目标类Target：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Singer</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;目标对象进行歌曲演唱&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代理类Proxy：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Singer</span> &#123;<br><span class="hljs-comment">//代理对象中，需要持有真正的目标对象的引用</span><br><span class="hljs-comment">//其目的是在完成辅助工作之后，使用目标对象来完成真正的核心工作</span><br><span class="hljs-keyword">private</span> Singer target;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">(Singer target)</span> &#123;<br><span class="hljs-built_in">this</span>.target = target;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//完成各种各种工作</span><br>System.out.println(<span class="hljs-string">&quot;安排时间&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;联系场地&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;安全保障&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;合同签订&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;费用结算&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br><span class="hljs-comment">//使用目标对象来完成核心工作</span><br><span class="hljs-built_in">this</span>.target.sing();<br>&#125;<br>&#125;    <br></code></pre></td></tr></table></figure><p><strong>用户类User：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Singer</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Target</span>();<br><span class="hljs-type">Singer</span> <span class="hljs-variable">singer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target);<br>singer.sing();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><h6 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h6><blockquote><p>借助java.lang.reflect.Proxy生成代理对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span><br></code></pre></td></tr></table></figure><ul><li><p>ClassLoader 目标类的类加载器 Target.class.getClassLoader()</p></li><li><p>Class&lt;?&gt;[] 目标类实现的接口数组   Target.class.getInterfaces()</p></li><li><p>InvocationHandler 增强业务逻辑 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proxy 产生的代理类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method 目标方法 target.sing “sing”</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args 目标方法的参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 目标方法执行的返回值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Obeject proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throw</span>&#123;<br>        <span class="hljs-type">Target</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Target.class.newInstance();<br>        <span class="hljs-comment">//目标方法执行</span><br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>        method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;world&quot;</span>);<br>        <span class="hljs-comment">//其他方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>公共接口Singer：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Singer</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>目标类Target：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Singer</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;目标对象进行歌曲演唱&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>用户类User：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Singer</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Target</span>();<br><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Target.class.getClassLoader();<br><br>        Class&lt;?&gt;[] interfaces = Target.class.getInterfaces();<br><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                System.out.println(<span class="hljs-string">&quot;安排场地&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;联系场地&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;安全保障&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;合同签订&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;费用结算&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;-------&quot;</span>);<br><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Singer</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Singer) Proxy.newProxyInstance(classLoader, interfaces, h);<br><br>        proxy.sing();<br><br>        System.out.println(proxy.getClass());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h6><p>目标类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveOrUpdate</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;操作成功&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CGLIBTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//CGLIB中产生代理对象的核心类型</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br><br>        <span class="hljs-comment">//设置代理类的父类模型</span><br>        enhancer.setSuperclass(StudentService.class);<br><br><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodInterceptor</span>() &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@param</span>   proxy   代理对象实例</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@param</span>   method  目标类中的方法对象</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@param</span>   args    方法参数</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@param</span>   methodProxy 方法代理对象</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(proxy,args);<br><br>                System.out.println(<span class="hljs-string">&quot;提交事务&quot;</span>);<br><br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">StudentService</span> <span class="hljs-variable">studentService</span> <span class="hljs-operator">=</span> (StudentService) enhancer.create();<br><br>        studentService.saveOrUpdate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p><strong>AOP: Aspect Oriented Programming  面向切面编程</strong> </p><p>通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术</p><p>是OOP的延续</p><p>利用AOP可以对业务逻辑的各个部分进行隔离，解耦，提高可重用性，提高开发效率</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>减少代码重复</li><li>提高开发效率</li><li>提高可维护性</li></ul><blockquote><p>Spring框架中，会自动根据目标对象是否实现了接口，来选择JDK动态代理的方式来实现，还是用CGLIB动态代理来实现</p></blockquote><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li><p>切面&#x2F;切面类(<strong>aspect</strong>)</p><p>将来要织入到方法执行 前&#x2F;后&#x2F;异常 的时候执行的代码片段</p></li><li><p>连接点(<strong>joinpoint</strong>)</p><p>spring中的连接点是目标对象里面需要被实现的方法，默认情况下是目标对象中所有非final修饰的方法</p><p>如果不是在Spring AOP中，joinPoint还可能是属性</p></li><li><p>切入点(<strong>pointcut</strong>)</p><p>一组连接点的集合，就是一个切入点，连接点是方法（Spring）所以一个切入点也是一组方法的集合</p><p><strong>execution：用于匹配方法执行连接点。这是使用Spring AOP时使用的主要点切割指示器。</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">修饰符 包名.类名.方法名称(方法参数)<br></code></pre></td></tr></table></figure><ul><li>修饰符：public、protected、private、包括返回值类型、static等等（使用<em>代表任意修饰符）</em></li><li>包名：如com.test（*代表全部，比如com.<em>代表com包下的全部包）</em></li><li>类名：使用*也可以代表包下的所有类</li><li>方法名称：可以使用*代表全部方法</li><li>方法参数：填写对应的参数即可，比如(String, String)，也可以使用*来代表任意一个参数，使用..代表所有参数。</li></ul></li><li><p>通知&#x2F;拦截器(<strong>advice</strong>)</p><p>控制 切面&#x2F;切面类 将来要在目标对象方法中什么位置执行</p></li><li><p>织入(<strong>wave</strong>)</p><p>将切面类织入到指定方法中执行的动作</p></li><li><p>目标对象(<strong>target</strong>)</p><p>需要被代理的对象，一般是指代理目标对象的一个或者多个指定的方法</p></li><li><p>代理对象(<strong>proxy</strong>)</p><p>代理目标对象，在完成核心功能的前提下，添加额外的代码去执行</p></li></ul><h4 id="xml实现"><a href="#xml实现" class="headerlink" title="xml实现"></a>xml实现</h4><h5 id="目标类接口"><a href="#目标类接口" class="headerlink" title="目标类接口"></a>目标类接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.springaop;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITeacherService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveOrUpdate</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteBatch</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="目标类"><a href="#目标类" class="headerlink" title="目标类"></a>目标类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.springaop;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeacherServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITeacherService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveOrUpdate</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;teacher:保存成功&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;teacher:删除成功&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteBatch</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;teacher:批量删除成功&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="切面类"><a href="#切面类" class="headerlink" title="切面类"></a>切面类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.springaop;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAdvice</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前置通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturn</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;后置通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwable</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;异常通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;最终通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;环绕通知：前&quot;</span>);<br>        <span class="hljs-comment">// 获取执行方法的参数</span><br>        Object[] args = joinPoint.getArgs();<br>        joinPoint.proceed(args);<br>        System.out.println(<span class="hljs-string">&quot;环绕通知: 后&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h5><blockquote><p>注意，该配置文件中，头部声明引入了aop相关的命名空间，以及指定了其对应的schema文件的位置</p></blockquote><p><img src="/../img/images/image-20230330010520950.png"></p><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacherService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kaf.springaop.TeacherServiceImpl&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kaf.springaop.MyAspect&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myPointcut1&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kaf.springaop..*.*(..))&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myPointcut2&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.kaf.springaop..*.delete*(..))&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;aspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myAspect&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;beforeAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myPointcut1&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;after&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myPointcut1&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;afterReturn&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myPointcut1&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;around&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;myPointcut2&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.springaop;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AOPXMLTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ITeacherService teacherService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(teacherService);<br>        System.out.println(teacherService.getClass());<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_saveOrUpdate</span><span class="hljs-params">()</span> &#123;<br>        teacherService.saveOrUpdate();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_delete</span><span class="hljs-params">()</span> &#123;<br>        teacherService.delete();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_deleteBatch</span><span class="hljs-params">()</span> &#123;<br>        teacherService.deleteBatch();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>&lt; aop:config &gt;</li></ul><p>  aop配置标签，所有的aop配置代码都写入该标签里面</p><ul><li><p>&lt; aop:pointcut &gt;</p><p>配置切入点，需要使用execution表示来定义切入点</p></li><li><p>&lt; aop:aspect &gt;</p><p>配置切面，所有通知都写入该里面</p><p>属性：</p><ul><li><p>id: 切面唯一标识</p></li><li><p>ref: 容器中切面对象的唯一标识</p></li></ul></li><li><p>advice</p><ul><li><p>&lt; aop:before &gt; 前置通知，在切入点执行之前执行</p></li><li><p>&lt; aop:after-returning &gt; 后置通知，在切入点执行之后执行，发生异常不执行</p></li><li><p>&lt; aop:after-throwing &gt; 异常通知，在切入点发生异常时执行</p></li><li><p>&lt; aop:after &gt; 最终通知，在切入点执行之后执行，发生异常也执行</p></li><li><p>&lt; aop:around &gt; 环绕通知，在切入点执行之前，执行一部分，执行后执行一部分</p></li></ul></li></ul><p>以上所有通知都有如下属性：</p><ul><li><p>method: 指定通知中方法的名称。</p></li><li><p>pointct: 定义切入点表达式（临时定义）</p></li><li><p>pointcut-ref: 指定切入点表达式的引用（引用上面定义好的）</p></li></ul><h4 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h4><h5 id="目标类接口-1"><a href="#目标类接口-1" class="headerlink" title="目标类接口"></a>目标类接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.springaop;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITeacherService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveOrUpdate</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteBatch</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="目标类-1"><a href="#目标类-1" class="headerlink" title="目标类"></a>目标类</h5><blockquote><p>加上@Service</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.service.impl;<br><br><span class="hljs-keyword">import</span> com.kaf.service.ITeacherService;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeacherServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITeacherService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveOrUpdate</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;teacher:保存成功&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;teacher:删除成功&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteBatch</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;teacher:批量删除成功&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="切面类-1"><a href="#切面类-1" class="headerlink" title="切面类"></a>切面类</h5><blockquote><p>切面类加入@Component注解，代替执行XML的bean配置，同时加入@Aspect注解，指定这是一个切面类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.aspect;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.kaf.service..*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut1</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.kaf.service..*.delete*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut2</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-meta">@Before(&quot;pointcut1()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAdvice</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前置通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterReturning(&quot;pointcut1()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturn</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;后置通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterThrowing(&quot;pointcut2()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwable</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;异常通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After(&quot;pointcut1()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;最终通知&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Around(&quot;pointcut1()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;环绕通知：前&quot;</span>);<br>        <span class="hljs-comment">// 获取执行方法的参数</span><br>        Object[] args = joinPoint.getArgs();<br>        joinPoint.proceed(args);<br>        System.out.println(<span class="hljs-string">&quot;环绕通知: 后&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h5><blockquote><p>编写配置类，代替XML文件的读取</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.kaf&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AOPConfig</span> &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>注意，@ComponentScan(“com.briup”)用来指定扫描com.briup包及其子包中类里面的注解信息</p></blockquote><blockquote><p>注意，@EnableAspectJAutoProxy用来指定当前spring配置中使用了AspectJ框架的注解</p></blockquote><blockquote><p>注意，AspectJ框架是专门实现AOP功能的一个框架，Spring中AOP功能也是依赖于AspectJ来实现的</p></blockquote><h5 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.springaop;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AOPXMLTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ITeacherService teacherService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(teacherService);<br>        System.out.println(teacherService.getClass());<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_saveOrUpdate</span><span class="hljs-params">()</span> &#123;<br>        teacherService.saveOrUpdate();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_delete</span><span class="hljs-params">()</span> &#123;<br>        teacherService.delete();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_deleteBatch</span><span class="hljs-params">()</span> &#123;<br>        teacherService.deleteBatch();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>@Aspect</li></ul><p>  声明该类是一个切面类</p><ul><li><p>@Before</p><p>声明方法为前置通知，value属性，用来指定引用的切入点是谁</p></li><li><p>@AfterReturning</p><p>声明方法为后置通知，value属性，用来指定引用的切入点是谁</p></li><li><p>@AfterThrowing</p><p>声明方法为异常通知，value属性，用来指定引用的切入点是谁</p></li><li><p>@After</p><p>声明方法为最终通知，value属性，用来指定引用的切入点是谁</p></li><li><p>@Around</p><p>声明方法为环绕通知，value属性，用来指定引用的切入点是谁</p></li><li><p>@Pointcut</p><p>定义切入点（一组方法的集合）</p></li></ul><h3 id="数据库框架整合"><a href="#数据库框架整合" class="headerlink" title="数据库框架整合"></a>数据库框架整合</h3><h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>Spring框架中提供的一个类 JdbcTemplate ，是对原始Jdbc-API的简单封装。除了这个模板类，Spring框</p><p>架为提供了很多的操作模板类：</p><ul><li><p>操作关系型数据库： JdbcTemplate , HibernateTemplate</p></li><li><p>操作redis数据库的： RedisTemplate</p></li><li><p>操作消息队列的： JmsTemplate</p></li></ul><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><h6 id="POJO类"><a href="#POJO类" class="headerlink" title="POJO类"></a>POJO类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.bean;<br><br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br>&#125;<br></code></pre></td></tr></table></figure><p>目标类接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.dao;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> com.kaf.bean.Teacher;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITeacherDao</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Teacher teacher)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Teacher teacher)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAll</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br><br>    Teacher <span class="hljs-title function_">selectById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br><br>    List&lt;Teacher&gt; <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">selectCount</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="目标类-2"><a href="#目标类-2" class="headerlink" title="目标类"></a>目标类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.dao.impl;<br><br><span class="hljs-keyword">import</span> com.kaf.bean.Teacher;<br><span class="hljs-keyword">import</span> com.kaf.dao.ITeacherDao;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.RowMapper;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TeacherDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITeacherDao</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Teacher t)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into teacher values(?,?,?,?)&quot;</span>;<br>        Object[] args = &#123;t.getId(),t.getName(),t.getAge(),t.getSalary()&#125;;<br>        jdbcTemplate.update(sql,args);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Teacher t)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update teacher set name = ?,age = ?,salary = ? where id = ?&quot;</span>;<br>        Object[] args = &#123;t.getName(),t.getAge(),t.getSalary(),t.getId()&#125;;<br>        jdbcTemplate.update(sql,args);    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delete from teacher&quot;</span>;<br>        jdbcTemplate.update(sql);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delete from teacher where id = ?&quot;</span>;<br>        Object[] args = &#123;id&#125;;<br>        jdbcTemplate.update(sql,args);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Teacher <span class="hljs-title function_">selectById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from teacher where id = ?&quot;</span>;<br>        Object[] args = &#123;id&#125;;<br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> jdbcTemplate.queryForObject(sql,args,<span class="hljs-keyword">new</span> <span class="hljs-title class_">RowMapper</span>&lt;Teacher&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> Teacher <span class="hljs-title function_">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-type">int</span> rowNum)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>                        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>                        t.setId(rs.getInt(<span class="hljs-string">&quot;id&quot;</span>));<br>                        t.setName(rs.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>                        t.setAge(rs.getInt(<span class="hljs-string">&quot;age&quot;</span>));<br>                        t.setSalary(rs.getDouble(<span class="hljs-string">&quot;salary&quot;</span>));<br>                        <span class="hljs-keyword">return</span> t;<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-keyword">return</span> teacher;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Teacher&gt; <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from teacher&quot;</span>;<br>        List&lt;Teacher&gt; list = jdbcTemplate.query(sql,<span class="hljs-keyword">new</span> <span class="hljs-title class_">RowMapper</span>&lt;Teacher&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Teacher <span class="hljs-title function_">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-type">int</span> index)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>                <span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>                teacher.setId(rs.getInt(<span class="hljs-string">&quot;id&quot;</span>));<br>                teacher.setName(rs.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>                teacher.setAge(rs.getInt(<span class="hljs-string">&quot;age&quot;</span>));<br>                teacher.setSalary(rs.getDouble(<span class="hljs-string">&quot;salary&quot;</span>));<br>                <span class="hljs-keyword">return</span> teacher;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">selectCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select count(*) from teacher&quot;</span>;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.queryForObject(sql, <span class="hljs-type">int</span>.class);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="配置类-1"><a href="#配置类-1" class="headerlink" title="配置类"></a>配置类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.config;<br><br><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSource;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span>: kaf(bl)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2023/3/31/22:40</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>：</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.kaf.dao&quot;)</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">jdbcConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        dataSource.setDriverClassName(<span class="hljs-string">&quot;oracle.jdbc.OracleDriver&quot;</span>);<br>        dataSource.setUrl(<span class="hljs-string">&quot;jdbc:oracle:thin:@127.0.0.1:1521:XE&quot;</span>);<br>        dataSource.setUsername(<span class="hljs-string">&quot;briup&quot;</span>);<br>        dataSource.setPassword(<span class="hljs-string">&quot;briup&quot;</span>);<br>        dataSource.setInitialSize(<span class="hljs-number">5</span>);<br>        dataSource.setMaxActive(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title function_">jdbcTemplate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">JdbcTemplate</span> <span class="hljs-variable">jdbcTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>();<br>        jdbcTemplate.setDataSource(dataSource());<br>        <span class="hljs-keyword">return</span> jdbcTemplate;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="测试类-2"><a href="#测试类-2" class="headerlink" title="测试类"></a>测试类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.test;<br><br><span class="hljs-keyword">import</span> com.kaf.bean.Teacher;<br><span class="hljs-keyword">import</span> com.kaf.config.jdbcConfig;<br><span class="hljs-keyword">import</span> com.kaf.dao.ITeacherDao;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(classes = jdbcConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ITeacherDao teacherDao;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_insert</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;tom1&quot;</span>, <span class="hljs-number">21</span>, <span class="hljs-number">2000</span>);<br>        teacherDao.insert(t);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_selectById</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> teacherDao.selectById(<span class="hljs-number">1</span>);<br>        System.out.println(t);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_selectAll</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Teacher&gt; list = teacherDao.selectAll();<br>        System.out.println(list);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_selectCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> teacherDao.selectCount();<br>        System.out.println(count);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_update</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;mary&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3000</span>);<br>        teacherDao.update(t);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_delete</span><span class="hljs-params">()</span> &#123;<br>        teacherDao.deleteById(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_deleteAll</span><span class="hljs-params">()</span> &#123;<br>        teacherDao.deleteAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Mybatis整合"><a href="#Mybatis整合" class="headerlink" title="Mybatis整合"></a>Mybatis整合</h4><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.oracle<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ojdbc8<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>10.2.0.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- Spring的JDBC支持框架 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h4 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><blockquote><p>在项目的三层架构设计中，事务管理工作需要放在service进行来处理，用来保证当前正在完成的业务功能要么同时成功，要么同时失败</p></blockquote><p>Spring操作事务的方式主要有两种：</p><ul><li><p>编程式事务</p><p>使用编程式的方式，自己去实现事务管理工作，例如事务的开启、提交、回滚操作，需要开发人员自己使用commit()或者rollback()等方法来实现</p><p>编程式事务需要我们自己在逻辑代码中手动书写事务控制逻辑，所以编程式事务是具有侵入性的。</p><p>我们之前的代码中，对事务进行提交或者回滚的操作，就属于编程式事务。</p></li><li><p>声明式事务</p><p>只需要声明或者配置一个事务就可以了，不需要我们手动去编写事务管理代码。</p><p>这种方式属于非侵入性的，可以使用AOP思想实现事务管理，能够提高代码的复用性，提高开发效率。</p><p>例如，在Spring中，使用AOP来实现事务操作</p><ul><li><p>将service层事务的开启、提交、回滚等代码抽出来，封装成切面类</p></li><li><p>使用环绕通知，将事务管理的代码织入到service层需要事务支持的方法中</p></li><li><p>获取service 实现类的代理对象，调用方法时会动态加入事务管理的代码</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2022/09/12/Mybatis/"/>
    <url>/2022/09/12/Mybatis/</url>
    
    <content type="html"><![CDATA[<p><strong>MyBatis 是一款优秀的持久层开源 ORM 框架  对jdbc进行封装</strong></p><span id="more"></span><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="什么是Mybatis"><a href="#什么是Mybatis" class="headerlink" title="什么是Mybatis"></a>什么是Mybatis</h3><blockquote><p><strong>MyBatis 是一款优秀的持久层开源框架，它支持自定义 SQL、存储过程以及高级映射。 MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。</strong></p><p><strong>MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old java Objects，普通老式 Java 对象）为数据库中的记录。MyBatis通过抽象底层的JDBC代码，自动化封装SQL结果集产生Java对象、Java对象的数据持久化数据库中的过程使得对SQL的使用变得容易</strong></p></blockquote><ul><li>持久层 和数据库相关</li><li>开源免费框架</li><li>框架：半成品项目</li><li>ORM：对象关系映射（自动映射 属性名和列名一致）</li></ul><blockquote><p><strong>如何获取Mybatis</strong></p><p>github地址 <a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></p><p>最新版本下载地址 <a href="https://github.com/mybatis/mybatis-3/releases">https://github.com/mybatis/mybatis-3/releases</a></p><p>doc文档 <a href="http://www.mybatis.org/mybatis-3/">http://www.mybatis.org/mybatis-3/</a></p></blockquote><h3 id="为什么学习"><a href="#为什么学习" class="headerlink" title="为什么学习"></a>为什么学习</h3><h4 id="JDBC六大步骤"><a href="#JDBC六大步骤" class="headerlink" title="JDBC六大步骤"></a>JDBC六大步骤</h4><ul><li><p>1.注册驱动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>2.获取连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/数据库名? characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span> );<br></code></pre></td></tr></table></figure></li><li><p>3.statement对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Statement</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> conn.createStatement();<br><span class="hljs-type">Statement</span> <span class="hljs-variable">pstat</span> <span class="hljs-operator">=</span> conn.prepareStatment(<span class="hljs-string">&quot;select * from user where username = ? and password = ?&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>4.执行sql</p></li><li><p>5.dql，处理结果集</p></li><li><p>6.关闭资源</p><ul><li>越晚开启越先关闭</li></ul></li></ul><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul><li>代码重复</li><li>效率低</li><li>sql硬编码</li><li>多表查询操作麻烦</li><li>….</li></ul><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><ul><li>手动封装</li><li>QueryRunner</li><li>JdbcTemplate</li><li>Mybatis框架(自定义sql) &#x2F; Hibernate框架&#x2F;jpa (面向对象sql)</li></ul><h4 id="Mybatis优势"><a href="#Mybatis优势" class="headerlink" title="Mybatis优势"></a>Mybatis优势</h4><ol><li>Myabtis消除了大量的JDBC冗余代码</li><li>Mybatis有低的学习曲线</li><li>Myabtis能很好的与传统数据库协同工作</li><li>Mybatis可以接受SQL语句</li><li>Mybatis提供了与Spring框架的集成支持</li><li>Mybatis提供了与第三方缓存类库的集成支持</li><li>Mybatis引入了更好的性能</li></ol><h3 id="Mybatis执行步骤"><a href="#Mybatis执行步骤" class="headerlink" title="Mybatis执行步骤"></a>Mybatis执行步骤</h3><ul><li>1.读取核心配置文件 mybatis-config.xml</li><li>2.加载映射文件 <ul><li>在配置文件中加载</li><li>包扫描 或者 mapper找到配置文件位置</li></ul></li><li>3.构造会话工厂SqlSessionFactory<ul><li>建造者模式</li></ul></li><li>4.创建会话对象SqlSession</li><li>5.Executor执行器<ul><li>负责SQL语句的生成和查询缓存维护</li><li>根据SqlSession传递的参数动态生成SQL语句</li></ul></li><li>6.MappedStatement对象<ul><li>一个动态SQL表情就是一个MappedStatement对象</li></ul></li><li>7.输入参数映射</li><li>8.封装结果集<ul><li>resultType</li><li>resultMap</li></ul></li></ul><h3 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h3><h4 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">&lt;!--</span> <span class="hljs-string"></span><br>     <span class="hljs-attr">属性</span>    <span class="hljs-string">&lt;properties/&gt;</span><br>     <span class="hljs-attr">设置</span>   <span class="hljs-string">&lt;settings/&gt;</span><br>     <span class="hljs-attr">类型命名</span>      <span class="hljs-string">&lt;typeAliases/&gt;</span><br>     <span class="hljs-attr">类型处理器</span>        <span class="hljs-string">&lt;typeHandlers/&gt;</span><br>     <span class="hljs-attr">对象工厂</span>   <span class="hljs-string">&lt;objectFactory/&gt;</span><br>     <span class="hljs-attr">插件</span>   <span class="hljs-string">&lt;plugins/&gt;</span><br>     <span class="hljs-attr">配置环境</span>    <span class="hljs-string">&lt;environments&gt;</span><br>     <span class="hljs-attr">环境变量</span>    <span class="hljs-string">&lt;environment&gt;</span><br>        <span class="hljs-attr">事务管理器</span>  <span class="hljs-string">&lt;transactionManager/&gt;</span><br>              <span class="hljs-attr">数据源</span>      <span class="hljs-string">&lt;dataSource/&gt;</span><br>     <span class="hljs-attr">环境变量</span>    <span class="hljs-string">&lt;/environment&gt;</span><br>     <span class="hljs-attr">配置环境</span>    <span class="hljs-string">&lt;/environments&gt;</span><br>     <span class="hljs-attr">数据库厂商标识</span>  <span class="hljs-string">&lt;databaseIdProvider/&gt;</span><br>   <span class="hljs-attr">映射器</span>     <span class="hljs-string">&lt;mappers/&gt;</span><br>   <span class="hljs-attr">&lt;/configuration&gt;</span><br>   <span class="hljs-attr">--&gt;</span><br></code></pre></td></tr></table></figure><h4 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#mysql datasource</span><br><span class="hljs-comment">#jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="hljs-comment">#jdbc.url=jdbc:mysql://127.0.0.1:3306/estore-nongda2018?useunicode=true;&amp;characterEncoding=utf8</span><br><span class="hljs-comment">#jdbc.username=root</span><br><span class="hljs-comment">#jdbc.password=root</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#oracle datasource</span><br><span class="hljs-attr">jdbc.driver</span>=<span class="hljs-string">oracle.jdbc.driver.OracleDriver</span><br><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:oracle:thin:@127.0.0.1:1521:XE</span><br><span class="hljs-attr">jdbc.username</span>=<span class="hljs-string">briup</span><br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-string">briup</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入db.properties文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resources</span>=<span class="hljs-string">&quot;db.properties&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="setting"><a href="#setting" class="headerlink" title="setting"></a>setting</h4><p><strong>默认配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-comment">&lt;!--这个配置使全局的映射器启用或禁用缓存--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--允许或不允许多种结果集从一个单独的语句中返回（需要适合的驱动） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;multipleResultSetsEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--使用列标签代替列名。不同的驱动在这方便表现不同。参考驱动文档或充分测试两种方法来决定所使用的驱动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useColumnLabel&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--允许JDBC支持生成的键。需要适合的驱动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useGeneratedKeys&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--指定MyBatis如何自动映射列到字段/属性。PARTIAL只会自动映射简单、没有嵌套的结果。FULL会自动映射任意复杂的结果（嵌套的或其他情况）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoMappingBehavior&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PARTIAL&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--配置默认的执行器。SIMPLE执行器没有什么特别之处。REUSE执行器重用预处理语句。BATCH执行器重用语句和批量更新--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultExecutorType&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SIMPLE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--设置超时时间，它决定驱动等待一个数据库响应的时间--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultStatementTimeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;25000&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--允许在嵌套语句中使用分页（RowBounds）默认false --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;safeRowBoundsEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典Java 属性名 aColumn 的类似映射。默认false--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localCacheScope&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SESSION&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcTypeForNull&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;OTHER&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--指定对象的哪个方法触发一次延迟加载。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;equals,clone,hashCode</span></span><br><span class="hljs-string"><span class="hljs-tag">,toString&quot;</span> /&gt;</span><br>#CGLIB | JAVASSIST 默认JAVASSIST(MyBatis 3.3 or above) <br><span class="hljs-comment">&lt;!--指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;proxyFactory&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;JAVASSIST&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;aggressiveLazyLoading&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--指定 MyBatis 所用日志的具体实现，未指定时将自动查找。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J &quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--指定 MyBatis 增加到日志名称的前缀。值可以是任意字符串--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logPrefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J &quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。 默认false--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;callSettersOnNulls&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false &quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h4><p>为mapper文件中resultType和parameterType属性的完全限定名取为别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">typerAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.kaf.pojo.Student&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">typerAliases</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="typeHandlers"><a href="#typeHandlers" class="headerlink" title="typeHandlers"></a>typeHandlers</h4><p><strong>自定义类型处理器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kaf.typehandler;<br><span class="hljs-keyword">import</span> java.sql.CallableStatement;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> org.apache.ibatis.type.BaseTypeHandler;<br><span class="hljs-keyword">import</span> org.apache.ibatis.type.JdbcType;<br><span class="hljs-keyword">import</span> com.kaf.pojo.PhoneNumber;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneTypeHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseTypeHandler</span>&lt;PhoneNumber&gt;&#123;<br><span class="hljs-comment">//遇到PhoneNumber参数的时候应该如何在ps中设置值</span><br>    <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNonNullParameter</span><span class="hljs-params">(PreparedStatement ps, <span class="hljs-type">int</span> i, PhoneNumber(parameter, JdbcType jdbcType)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>ps.setString(i, parameter.getAsString());<br>&#125;<br><span class="hljs-comment">//查询中遇到PhoneNumber类型的应该如何封装(使用列名封装)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PhoneNumber <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(ResultSet rs, String columnName)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhoneNumber</span>(rs.getString(columnName));<br>&#125;<br><span class="hljs-comment">//查询中遇到PhoneNumber类型的应该如何封装(使用列的下标)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PhoneNumber <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(ResultSet rs, <span class="hljs-type">int</span> columnIndex)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhoneNumber</span>(rs.getString(columnIndex));<br>&#125;<br><span class="hljs-comment">//CallableStatement使用中遇到了PhoneNumber类型的应该如何封装</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PhoneNumber <span class="hljs-title function_">getNullableResult</span><span class="hljs-params">(CallableStatement cs, <span class="hljs-type">int</span> columnIndex)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhoneNumber</span>(cs.getString(columnIndex));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在核心配置文件里注册</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">&lt;typeHandlers&gt;</span><br><span class="hljs-attr">&lt;typerHandler</span> <span class="hljs-string">handler=&quot;com.briup.typehandlers.PhoneTypeHandle&quot; /&gt;</span><br><span class="hljs-attr">&lt;typerHandlers/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="enviroments"><a href="#enviroments" class="headerlink" title="enviroments"></a>enviroments</h4><p>environments是配置mybatis当前工作的数据库环境的地方</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;shoppingcart&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;shoppingcart&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;MANAGED&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JNDI&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data_source&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;java:comp/jdbc/ShoppingcartDS&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;reports&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">transaction</span> <span class="hljs-attr">Managertype</span>=<span class="hljs-string">&quot;MANAGED&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JNDI&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;data_source&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;java:comp/jdbc/ReportsDS&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>可以伟以上每个环境创建一个SqlSessionFactory</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">inputStream = Resources.getResourceAsSteam(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br><span class="hljs-comment">//默认环境 default （根据defalut配置）</span><br>SqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br><span class="hljs-comment">//shoppingcart环境</span><br>SqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream,<span class="hljs-string">&quot;shoppingcart&quot;</span>);<br><span class="hljs-comment">//reports环境</span><br>SqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream，<span class="hljs-string">&quot;reports&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="dataSource"><a href="#dataSource" class="headerlink" title="dataSource"></a>dataSource</h4><p>dataSource表示的是数据源，至少包含四种连接数据库的信息</p><ul><li>drive</li><li>url</li><li>username</li><li>password</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>type属性可以配置成UNPOOLED, POOLED, JNDI</strong></p><ul><li>UNPOOLED  适用于小规模数量并发用户的简单应用程序</li><li>POOLED  创建一个数据库连接池，连接池的一个连接回呗用作数据库的操作</li><li>JNDI</li></ul><h4 id="transactionManager"><a href="#transactionManager" class="headerlink" title="transactionManager"></a>transactionManager</h4><p><strong>事务管理器</strong></p><ul><li>JDBC 应用层序自己管理事务</li><li>MANAGERD 托管事务，程序本身不去管理，把事务管理交给所在服务器管理</li></ul><h4 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h4><p><strong>加载映射文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/kaf/mappers/StudentMapper.xml&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file:///D:/mybatisdemo/app/mappers/StudentMapper.xml&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.briup.dao.StudentMapper&quot;</span> /&gt;</span><br>#包扫描（常用）<br><span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.briup.mappers&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="映射文件配置"><a href="#映射文件配置" class="headerlink" title="映射文件配置"></a>映射文件配置</h3><h4 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h4><blockquote><p>insert</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span><br>insert into STUDENTS(id, name, email, dob)<br>values (#&#123;id&#125;,#)<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;处理空置&#x3D;&#x3D;</p><ul><li><p>局部处理 : #{name,jdbcType&#x3D;VARCHAR}</p></li><li><p>全局处理:</p><ul><li>&#96;&#96;&#96;xml<settings>    <setting name="jdbcTypeForNull" value="VARCHAR"/></settings><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"></span><br><span class="language-xml">==主键回填==</span><br><span class="language-xml"></span><br><span class="language-xml">```xml</span><br><span class="language-xml"> <span class="hljs-comment">&lt;!--先从哑表查找值 放入id属性中--&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span></span><br><span class="language-xml">    // selectKey: 查找主键</span><br><span class="language-xml">    order: select 优先于 insert执行</span><br><span class="language-xml">    keyProperty: 封装到student的id属性中去</span><br><span class="language-xml">    resultType: 序列的返回值 (属性id的类型)</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span></span><br><span class="language-xml">        select user_seq.nextval from dual</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span></span><br><span class="language-xml">    insert into STUDENTS(id, name, email, dob)</span><br><span class="language-xml">    values (#</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;email&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;dob&#125;</span><span class="language-xml">)</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>update</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--修改学生--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span><br>    update STUDENTS<br>    set name = #&#123;name&#125; , email = #&#123;email&#125;<br>    where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>delete</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--删除学生--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>    delete from STUDENTS<br>    where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>select   orm: 列名和属性名一致</p></blockquote><ul><li>返回单个对象 resultType &#x3D; “student”<ul><li>resultType &#x3D; “student”</li><li>组函数 select count(id) from students <code>resultType =&quot;int&quot;</code></li></ul></li><li>返回对象集合 resultType &#x3D; “student”<ul><li>select name from students; <code>resultType =&quot;string&quot;</code></li></ul></li><li>返回单个map<ul><li>所有列和值  都封装到map<ul><li>id,2   name:tom</li></ul></li></ul></li><li>返回map集合</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--select insert update delete--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span><br>    select id, name, email, dob, phone as phoneNumber<br>    from STUDENTS<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--查询指定学生--&gt;</span><br><span class="hljs-comment">&lt;!--#&#123;id&#125; 只有一个参数的情况 #&#123;任意填写&#125;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span><br>    select id, name, email, dob, phone as phoneNumber<br>    from STUDENTS<br>    where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--查询封装到map中--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findByIdWithMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    select id, name, email, dob, phone as phoneNumber<br>    from STUDENTS<br>    where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--查询封装到List&lt;map&gt;中--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findByIdWithMapList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    select id, name, email, dob, phone as phoneNumber<br>    from STUDENTS<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--学生个数--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findCount&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>    select count(id)<br>    from STUDENTS<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!--学生名称--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findNameList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;string&quot;</span>&gt;</span><br>    select name<br>    from STUDENTS<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;sql片段&#x3D;&#x3D;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stuSql&quot;</span>&gt;</span><br>    id, name, email, dob, phone as phoneNumber<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><span class="hljs-comment">&lt;!--select insert update delete--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span><br>    select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;stuSql&quot;</span>/&gt;</span><br>    from STUDENTS<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;列名和属性名不一致&#x3D;&#x3D;</p><ul><li><p>自动映射 (列名和属性名一致) 取别名</p></li><li><p><code>高级映射 resultMap </code>   手动处理列名和属性名的关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--自定义映射规则</span><br><span class="hljs-comment">        type: 返回的类型</span><br><span class="hljs-comment">        id: 该标签的唯一标识</span><br><span class="hljs-comment">    --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stuMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--具体映射规则--&gt;</span><br>    <span class="hljs-comment">&lt;!--主键 映射--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--非主键映射--&gt;</span><br>    <span class="hljs-comment">&lt;!--&lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;</span><br><span class="hljs-comment">        &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt;</span><br><span class="hljs-comment">        &lt;result property=&quot;dob&quot; column=&quot;dob&quot;/&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;phoneNumber&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;phone&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-comment">&lt;!--select insert update delete--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAll&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;stuMap&quot;</span>&gt;</span><br>    select id, name, email, dob, phone<br>    from STUDENTS<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="多表"><a href="#多表" class="headerlink" title="多表"></a>多表</h4><p>&#x3D;&#x3D;多表无法使用resultType自动映射 需要resultMap高级映射&#x3D;&#x3D;</p><blockquote><p>一对一  resultmap可以有继承关系</p></blockquote><p>&#x3D;&#x3D;原始写法&#x3D;&#x3D;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--手动映射一对一的关系--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stuMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--封装学生--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;studId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>       <span class="hljs-comment">&lt;!-- &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;</span><br><span class="hljs-comment">        &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt;</span><br><span class="hljs-comment">        &lt;result property=&quot;dob&quot; column=&quot;dob&quot;/&gt;</span><br><span class="hljs-comment">        &lt;result property=&quot;phone&quot; column=&quot;phone&quot;/&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--封装地址--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address.addrId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;addr_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address.street&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;street&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address.city&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;city&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address.state&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;state&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address.zip&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;zip&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address.country&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;country&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--查找学生以及地址--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;stuMap&quot;</span>&gt;</span><br>        select s.id, s.name, s.email, s.dob, s.phone, s.addr_id,<br>               a.addr_id, a.street, a.city, a.state, a.zip, a.country<br>        from STUDENTS s,<br>             ADDRESSES a<br>        where s.ADDR_ID = a.ADDR_ID<br>              and s.id = #&#123;sid&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>嵌套结果查询(关联查询)    一次性查询所有表的结果(通过关联标签 assocation) 封装各map中取</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--手动映射一对一的关系--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stuMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--封装学生--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;studId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--关联关系 一对一 assoscition--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;addMap&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;addrId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;addr_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;street&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;street&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;city&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;state&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;state&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;zip&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;zip&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;country&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--封装地址--&gt;</span><br><br>    <span class="hljs-comment">&lt;!--查找学生以及地址--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;stuMap&quot;</span>&gt;</span><br>        select s.id, s.name, s.email, s.dob, s.phone, s.addr_id,<br>               a.addr_id, a.street, a.city, a.state, a.zip, a.country<br>        from STUDENTS s,<br>             ADDRESSES a<br>        where s.ADDR_ID = a.ADDR_ID<br>              and s.id = #&#123;sid&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>嵌套sql查询(子查询)   分批次查结果</p></blockquote><ul><li><code>select s.id, s.name, s.email, s.dob, s.phone, s.addr_id(1) from students s</code></li><li><code>select a.addr_id, a.street, a.city, a.state, a.zip, a.country from addresses a where a.addr_id = 上一次查的addr_id 1</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--手动映射一对一的关系--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stuMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--封装学生--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;studId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>       <span class="hljs-comment">&lt;!--关联关系 一对一 assoscition</span><br><span class="hljs-comment">           关联的时候 发送第二次sql</span><br><span class="hljs-comment">           select: 发送第二次sql的id</span><br><span class="hljs-comment">           column: 发送第二次sql的id的条件</span><br><span class="hljs-comment">       --&gt;</span><br><br>       <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;findAddrByAddrId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;addr_id&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--封装地址--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;addrId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;addr_id&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;street&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;street&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;city&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;state&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;state&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;zip&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;zip&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;country&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stuSql&quot;</span>&gt;</span><br>       s.id, s.name, s.email, s.dob, s.phone, s.addr_id<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addSql&quot;</span>&gt;</span><br>       a.addr_id, a.street, a.city, a.state, a.zip, a.country<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--查找学生以及地址 addr_id = 2--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;stuMap&quot;</span>&gt;</span><br>       select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;stuSql&quot;</span>/&gt;</span><br>       from STUDENTS s<br>       where id = #&#123;id&#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--根据id查询地址 参数来源于assosication select column=&quot;addr_id&quot;--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findAddrByAddrId&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;addMap&quot;</span>&gt;</span><br>       select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;addSql&quot;</span>/&gt;</span><br>       from ADDRESSES<br>       where id = #&#123;id&#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>一对多</p></blockquote><p>&#x3D;&#x3D;嵌套结果查询&#x3D;&#x3D;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.briup.mybatis.mapper.OneToManyMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tutorMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;tutor&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tutorId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tutor_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;phone&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;phone&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--address:  assocation--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;addMap&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--courses:  collection--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;courses&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;courseMap&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--地址map--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;addrId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;addr_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;street&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;street&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;city&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;state&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;state&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;zip&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;zip&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;country&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--课程map--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;courseMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;course&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;courseId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;course_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;description&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;startDate&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;start_date&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;endDate&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;end_date&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;tutorMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>        select<br>            t.tutor_id, t.name, t.email, t.phone, t.addr_id,<br>            a.addr_id, a.street, a.city, a.state, a.zip, a.country,<br>            c.course_id, c.name, c.description, c.start_date, c.end_date, c.tutor_id<br>        from TUTORS t<br>                 left join COURSES c on t.TUTOR_ID = c.TUTOR_ID<br>                 left join ADDRESSES a on t.ADDR_ID = a.ADDR_ID<br>                 where t.TUTOR_ID = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>嵌套sql查询</strong>&#x3D;&#x3D;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.briup.mybatis.mapper.OneToManyMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tutorMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;tutor&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tutorId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tutor_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;phone&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;phone&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--address:  assocation--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;selectAddrById&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;addr_id&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--courses:  collection--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;courses&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;selectCourseById&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tutor_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--地址map--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;addrId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;addr_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;street&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;street&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;city&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;state&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;state&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;zip&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;zip&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;country&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--课程map--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;courseMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;course&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;courseId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;course_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;description&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;startDate&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;start_date&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;endDate&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;end_date&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;tutorMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>        select<br>            t.tutor_id, t.name, t.email, t.phone, t.addr_id<br>        from TUTORS t<br>        where t.TUTOR_ID = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAddrById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;addMap&quot;</span>&gt;</span><br>        select<br>            a.addr_id, a.street, a.city, a.state, a.zip, a.country<br>        from ADDRESSES a<br>        where a.ADDR_ID = #&#123;addrId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectCourseById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;courseMap&quot;</span>&gt;</span><br>        select<br>            c.course_id, c.name, c.description, c.start_date, c.end_date, c.tutor_id<br>        from COURSES c<br>        where c.TUTOR_ID = #&#123;tutorId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>多对多</p></blockquote><p><code>传多个参数</code></p><ul><li><p>实体类 id name email</p></li><li><p>map   key1 key2 key3</p></li><li><p>#{param1} #{param2}  </p><ul><li>&#96;&#96;&#96;sql<br>int insertStuAndCou(@Param(“stu”) Student stu,@Param(“cou”) Course cou);<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"></span><br><span class="language-xml">    </span><br><span class="language-xml"></span><br><span class="language-xml">```xml</span><br><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="hljs-meta"><span class="language-xml">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.briup.mybatis.mapper.ManyToManyMapper&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertStu&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span></span><br><span class="language-xml">            select STU_SEQ.nextval from dual</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span></span><br><span class="language-xml">        insert into STUDENT(id, name, gender, major, grade)</span><br><span class="language-xml">        values (#</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;name&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;gender&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;major&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;grade&#125;</span><span class="language-xml">)</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertCou&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;course&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span></span><br><span class="language-xml">            select STU_SEQ.nextval from dual</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span></span><br><span class="language-xml">        insert into COURSE(id, course_code, course_name)</span><br><span class="language-xml">        values (#</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;courseCode&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;courseName&#125;</span><span class="language-xml">)</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--多参数:</span></span><br><span class="hljs-comment"><span class="language-xml">        #</span></span><span class="hljs-template-variable">&#123;param1.id&#125;</span><span class="language-xml"><span class="hljs-comment"> student</span></span><br><span class="hljs-comment"><span class="language-xml">    --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertStuAndCou&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span></span><br><span class="language-xml">            select STU_SEQ.nextval from dual</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span></span><br><span class="language-xml">        insert into STUDENT_COURSE(id, student_id, course_id)</span><br><span class="language-xml">        values (#</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;stu.id&#125;</span><span class="language-xml">,#</span><span class="hljs-template-variable">&#123;cou.id&#125;</span><span class="language-xml">)</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stuMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;major&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;major&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;grade&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;grade&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;courses&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;courseMap&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;courseMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;course&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;courseCode&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;course_code&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;courseName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;course_name&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStuById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;stuMap&quot;</span>&gt;</span></span><br><span class="language-xml">        select</span><br><span class="language-xml">            s.id, s.name, s.gender, s.major, s.grade,</span><br><span class="language-xml">            c.ID, c.COURSE_CODE, c.COURSE_NAME</span><br><span class="language-xml">        from STUDENT s,</span><br><span class="language-xml">             COURSE c,</span><br><span class="language-xml">             STUDENT_COURSE sc</span><br><span class="language-xml">        where s.ID = sc.STUDENT_ID</span><br><span class="language-xml">          and c.ID = sc.COURSE_ID</span><br><span class="language-xml">          and s.ID = #</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="多参数"><a href="#多参数" class="headerlink" title="多参数"></a>多参数</h4><ul><li>map</li><li>类类型 </li><li>#{param1} #{param2}   @Param(“”)</li></ul><h3 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h3><blockquote><p>if  解决参数非空拼接  但是对where支持不友好</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectWithIf&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;course&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>        select<br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;couSql&quot;</span>/&gt;</span><br>        from COURSES<br>        where tutor_id = #&#123;tutorId&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;courseName != null&quot;</span>&gt;</span><br>            and name like concat(concat(&#x27;%&#x27;,#&#123;courseName&#125;),&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;startDate != null&quot;</span>&gt;</span><br>            and start_date &gt;= #&#123;start_date&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>where 能解决if的问题    1.如果条件成立 自动拼接were  2.如果条件是以or或者and 会自动去除</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectWithWhere&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;course&quot;</span>&gt;</span><br>        select<br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;couSql&quot;</span>/&gt;</span><br>        from COURSES<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;courseName != null&quot;</span>&gt;</span><br>                and name like concat(concat(&#x27;%&#x27;,#&#123;courseName&#125;),&#x27;%&#x27;)<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;startDate != null&quot;</span>&gt;</span><br>                and start_date &gt;= #&#123;startDate&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>trim 增强了where功能     加&#x2F;去 前缀    加&#x2F;去后缀</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectWithTrim&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;course&quot;</span>&gt;</span><br>    select<br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;couSql&quot;</span>/&gt;</span><br>    from COURSES<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;and&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;courseName != null&quot;</span>&gt;</span><br>            and name like concat(concat(&#x27;%&#x27;,#&#123;courseName&#125;),&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;startDate != null&quot;</span>&gt;</span><br>            and start_date &gt;= #&#123;startDate&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>choose    提供大范围分类 再精确查找</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectWithChoose&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;course&quot;</span>&gt;</span><br>       select<br>           <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;couSql&quot;</span>/&gt;</span><br>       from COURSES<br>       <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;selectType == courseName&quot;</span>&gt;</span><br>               where name like concat(concat(&#x27;%&#x27;,#&#123;courseName&#125;),&#x27;%&#x27;)<br>           <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;selectType == d&quot;</span>&gt;</span><br>               where start_date &gt;= #&#123;startDate&#125;<br>           <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testChoose</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> SqlSessionUtil.openSession();<br>        <span class="hljs-type">DynamicMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(DynamicMapper.class);<br>        <span class="hljs-comment">// 模拟搜索框  map 存在 key 搜索条件</span><br>        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//        map.put(&quot;selectType&quot;,&quot;courseName&quot;);</span><br>        map.put(<span class="hljs-string">&quot;selectType&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>);<br><br><span class="hljs-comment">//        map.put(&quot;courseName&quot;,&quot;J&quot;); // (具体)</span><br>        map.put(<span class="hljs-string">&quot;startDate&quot;</span>,LocalDate.of(<span class="hljs-number">2022</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>));<br>        List&lt;Course&gt; courses = mapper.selectWithChoose(map);<br>        System.out.println(courses);<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>foreach 标签 构建循环</p></blockquote><p>形式1 where id &#x3D; 1 or id &#x3D; 2</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--批量查询--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectWithForeach&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;course&quot;</span>&gt;</span><br>        select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;couSql&quot;</span>/&gt;</span><br>        from COURSES<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ids != null&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>                    or COURSE_ID = #&#123;id&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> course_id <span class="hljs-keyword">as</span> courseId, name, description, start_date <span class="hljs-keyword">as</span> startDate, end_date <span class="hljs-keyword">as</span> endDate, tutor_id <span class="hljs-keyword">as</span> tutorId <span class="hljs-keyword">from</span> COURSES <span class="hljs-keyword">WHERE</span> COURSE_ID <span class="hljs-operator">=</span> ? <span class="hljs-keyword">or</span> COURSE_ID <span class="hljs-operator">=</span> ? <span class="hljs-keyword">or</span> COURSE_ID <span class="hljs-operator">=</span> ? <span class="hljs-keyword">or</span> COURSE_ID <span class="hljs-operator">=</span> ? <span class="hljs-keyword">or</span> COURSE_ID <span class="hljs-operator">=</span> ? <br></code></pre></td></tr></table></figure><p>形式2  where id in(1,2,3,4,5)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectWithForeach&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;course&quot;</span>&gt;</span><br>        select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;couSql&quot;</span>/&gt;</span><br>        from COURSES<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ids != null&quot;</span>&gt;</span><br>                 COURSE_ID in<br>                <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>                       #&#123;id&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>set 选择性更新    如果if条件成立 自动拼接前缀set,自动去除最后条件 ‘,’</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectiveUpdate&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;course&quot;</span>&gt;</span><br>    update COURSES<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null&quot;</span>&gt;</span>name=#&#123;name&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;description!=null&quot;</span>&gt;</span>description=#&#123;description&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;startDate!=null&quot;</span>&gt;</span>start_date=#&#123;startDate&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;endDate!=null&quot;</span>&gt;</span>end_date=#&#123;endDate&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;courseId != null&quot;</span>&gt;</span><br>            COURSE_ID = #&#123;courseId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>封装</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.briup.mybatis.util;<br><br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span>: vanse(lc))</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2022/9/29-09-29-9:25</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>：获取SqlSession的工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlSessionUtil</span> &#123;<br>    <span class="hljs-comment">// 单例模式</span><br>    <span class="hljs-comment">// 1.构造器私有 2.提前创建一个实例 3.提供静态方法返回该实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory <span class="hljs-title function_">getSqlSessionFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>            <span class="hljs-comment">// 只有第一次会创建该实例</span><br>            <span class="hljs-keyword">if</span> (sqlSessionFactory == <span class="hljs-literal">null</span>) &#123;<br>                sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(in);<br>            &#125;<br>            <span class="hljs-keyword">return</span> sqlSessionFactory;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">openSession</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 默认是自动提交</span><br>        <span class="hljs-keyword">return</span> getSqlSessionFactory().openSession(<span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-comment">// true: 自动提交</span><br>    <span class="hljs-comment">// false: 手动提交</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">openSession</span><span class="hljs-params">(<span class="hljs-type">boolean</span> autoCommit)</span> &#123;<br>        <span class="hljs-comment">// 默认是自动提交</span><br>        <span class="hljs-keyword">return</span> getSqlSessionFactory().openSession(autoCommit);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>日志</strong></p><blockquote><p>mybatis默认根据日志实现 推测 (如果没有实现类 默认没有日志)</p></blockquote><ul><li>SLF4J</li><li>Apache Commons Logging</li><li>Log4j2</li><li>Log4j</li><li>JDK logging</li></ul><p><strong>步骤</strong></p><ul><li>继承依赖</li><li>配置文件 <code>log4j.properties</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">2022-09-29 10:09:16,145 [DEBUG] com.briup.mybatis.mapper.StudentMapper.findById - ==&gt;  Preparing: select id, name, email, dob, phone as phoneNumber from STUDENTS where id = ? <br>2022-09-29 10:09:16,269 [DEBUG] com.briup.mybatis.mapper.StudentMapper.findById - ==&gt; Parameters: 2(Integer)<br>2022-09-29 10:09:16,345 [DEBUG] com.briup.mybatis.mapper.StudentMapper.findById - &lt;==      Total: 1<br>2022-09-29 10:09:16,345 [TRACE] com.briup.mybatis.TestStudent - Student&#123;id=2, name=&#x27;null&#x27;, email=&#x27;briup@qq.com&#x27;, dob=Wed Sep 28 17:01:05 CST 2022, phoneNumber=PhoneNumber&#123;countryCode=&#x27;111&#x27;, stateCode=&#x27;222&#x27;, number=&#x27;333&#x27;&#125;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java网络编程</title>
    <link href="/2022/09/08/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/09/08/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h1><h3 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h3><p>通过网络访问其他计算机，并通过IP地址区分不同计算机，每一台电脑在同一个网络上都有一个自己的IP地址，用于区别于其他电脑，可以通过对方主机的IP地址对其进行访问（<strong>注意：属于同一个网络</strong>）</p><p>我们电脑上可能运行着大量程序，每一个程序可能都需要通过网络来访问其他计算机，我们可以通过端口号区分：</p><p>因此，我们一半看到的是这样的：<code>192.168.0.11 : 8080</code>，通过<code>IP:端口</code>的形式来访问目标主机上的一个应用程序服务（<strong>注意：端口号只能是0-65535之间的值</strong>）</p><p>IP地址分为IPv4和IPv6，IPv4类似于<code>192.168.0.11</code>，我们上面提到的例子都是使用的IPv4，它一共有四组数字，每组数字占8个bit位，IPv4地址<code>0.0.0.0</code>表示为2进制就是：00000000.00000000.00000000.00000000，共32个bit，最大为<code>255.255.255.255</code>，实际上，IPv4能够表示的所有地址，早就已经被用完了。IPv6能够保存128个bit位，因此它也可以表示更多的IP地址，一个IPv6地址看起来像这样：<code>1030::C9B4:FF12:48AA:1A2B</code>，目前也正在向IPv6的阶段过度。</p><p>TCP和UDP是两种不同的传输层协议：</p><ul><li>TCP：当一台计算机想要与另外一台计算机通讯时，两台计算机之间的通信需要畅通且可靠（会进行三次握手，断开也会进行四次挥手），这样才能保证正确收发数据，因此TCP更适合一些可靠的数据传输场景</li><li>UDP：它是一种无连接协议，数据想发就发，而且不会建立可靠传输，也就是说传输过程中有可能会导致部分数据丢失，但是它比TCP传输更加简单高效，适合视频直播之类的。</li></ul><p><img src="/../img/images/TCPandUDP.jpg"></p><hr><h3 id="了解Socket技术"><a href="#了解Socket技术" class="headerlink" title="了解Socket技术"></a>了解Socket技术</h3><p>通过Socket技术（它是计算机之间进行<strong>通信</strong>的<strong>一种约定</strong>或一种方式），可以实现两台计算机之间的通信，Socket也被翻译为<code>套接字</code>，是操作系统底层提供的一项通信技术，它支持TCP和UDP。而Java就对socket底层支持进行了一套完整的封装，可以通过Java来实现Socket通信。</p><p>要实现Socket通信，必须创建一个数据发送者和一个数据接收者，也就是客户端和服务端，我们需要提前启动服务端，来等待客户端的连接，而客户端只需要随时启动去连接服务端即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8088</span>))&#123;<br>        System.out.println(<span class="hljs-string">&quot;正在客户端等待连接.....&quot;</span>);<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> server.accept();<br>        System.out.println(<span class="hljs-string">&quot;连接成功，IP地址为&quot;</span> + socket.getInetAddress().getHostAddress());<br>    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">8088</span>))&#123;<br>        System.out.println(<span class="hljs-string">&quot;已连接到服务端!&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e )&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端连接失败！&quot;</span>);<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上它就是一个TCP连接的建立过程</p><p>一旦TCP连接建立，服务端和客户端之间就可以相互发送数据，直到客户端主动关闭连接。当然，服务端不仅仅只可以让一个客户端进行连接，我们可以尝试让服务端一直运行来不断接受客户端的连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8088</span>))&#123;<br>        System.out.println(<span class="hljs-string">&quot;正在客户端等待连接.....&quot;</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> server.accept();<br>        System.out.println(<span class="hljs-string">&quot;连接成功，IP地址为&quot;</span> + socket.getInetAddress().getHostAddress());<br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="使用Socket进行数据传输"><a href="#使用Socket进行数据传输" class="headerlink" title="使用Socket进行数据传输"></a>使用Socket进行数据传输</h3><p>通过Socket对象，就可以获取到对应的I&#x2F;O流进行网络数据传输：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8088</span>);<br>             <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in))&#123;<br>            System.out.println(<span class="hljs-string">&quot;已连接到服务端！&quot;</span>);<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>            <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(stream);  <span class="hljs-comment">//通过转换流来快速写入内容</span><br>            System.out.println(<span class="hljs-string">&quot;请输入要发送给服务端的内容：&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>            writer.write(text+<span class="hljs-string">&#x27;\n&#x27;</span>);   <span class="hljs-comment">//因为对方是readLine()这里加个换行符</span><br>            writer.flush();<br>            System.out.println(<span class="hljs-string">&quot;数据已发送：&quot;</span>+text);<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;服务端连接失败！&quot;</span>);<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;客户端断开连接！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8088</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8088上</span><br>        System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> server.accept();<br>        System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));  <br>        System.out.print(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>);<br>        System.out.println(reader.readLine());<br>          socket.close();   <span class="hljs-comment">//和服务端TCP连接完成之后，记得关闭socket</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，既然服务端可以读取客户端的内容，客户端也可以在发送后等待服务端给予响应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8088</span>);<br>         <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in))&#123;<br>        System.out.println(<span class="hljs-string">&quot;已连接到服务端！&quot;</span>);<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>        <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(stream);  <span class="hljs-comment">//通过转换流来帮助我们快速写入内容</span><br>        System.out.println(<span class="hljs-string">&quot;请输入要发送给服务端的内容：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        writer.write(text+<span class="hljs-string">&#x27;\n&#x27;</span>);   <span class="hljs-comment">//因为对方是readLine()这里加个换行符</span><br>        writer.flush();<br>        System.out.println(<span class="hljs-string">&quot;数据已发送：&quot;</span>+text);<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br>        System.out.println(<span class="hljs-string">&quot;收到服务器返回：&quot;</span>+reader.readLine());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务端连接失败！&quot;</span>);<br>        e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;客户端断开连接！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8088</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8088上</span><br>        System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> server.accept();<br>        System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));  <span class="hljs-comment">//通过</span><br>        System.out.print(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>);<br>        System.out.println(reader.readLine());<br>        <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(socket.getOutputStream());<br>        writer.write(<span class="hljs-string">&quot;已收到！&quot;</span>);<br>        writer.flush();<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以手动关闭单向的流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">socket.shutdownOutput();  <span class="hljs-comment">//关闭输出方向的流</span><br>socket.shutdownInput();  <span class="hljs-comment">//关闭输入方向的流</span><br></code></pre></td></tr></table></figure><p>如果不希望服务端等待太长的时间，可以通过调用<code>setSoTimeout()</code>方法来设定IO超时时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">socket.setSoTimeout(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><p>当超过设定时间都依然没有收到客户端或是服务端的数据时，会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">java.net.SocketTimeoutException: Read timed out<br>    at java.net.SocketInputStream.socketRead0(Native Method)<br>    at java.net.SocketInputStream.socketRead(SocketInputStream.java:<span class="hljs-number">116</span>)<br>    at java.net.SocketInputStream.read(SocketInputStream.java:<span class="hljs-number">171</span>)<br>    at java.net.SocketInputStream.read(SocketInputStream.java:<span class="hljs-number">141</span>)<br>    at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:<span class="hljs-number">284</span>)<br>    at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:<span class="hljs-number">326</span>)<br>    at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:<span class="hljs-number">178</span>)<br>    at java.io.InputStreamReader.read(InputStreamReader.java:<span class="hljs-number">184</span>)<br>    at java.io.BufferedReader.fill(BufferedReader.java:<span class="hljs-number">161</span>)<br>    at java.io.BufferedReader.readLine(BufferedReader.java:<span class="hljs-number">324</span>)<br>    at java.io.BufferedReader.readLine(BufferedReader.java:<span class="hljs-number">389</span>)<br>    at com.test.Main.main(Main.java:<span class="hljs-number">41</span>)<br></code></pre></td></tr></table></figure><p>我们之前使用的都是通过构造方法直接连接服务端，那么是否可以等到我们想要的时候再去连接呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(); <span class="hljs-comment">//调用无参构造不会自动连接</span><br>     <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in))&#123; <br>    socket.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>), <span class="hljs-number">1000</span>);  <span class="hljs-comment">//手动调用connect方法进行连接</span><br></code></pre></td></tr></table></figure><p>如果连接的双方发生意外而通知不到对方，导致一方还持有连接，这样就会占用资源，因此我们可以使用<code>setKeepAlive()</code>方法来防止此类情况发生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">socket.setKeepAlive(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>当客户端连接后，如果设置了keeplive为 true，当对方没有发送任何数据过来，超过一个时间(看系统内核参数配置)，那么我们这边会发送一个ack探测包发到对方，探测双方的TCP&#x2F;IP连接是否有效。</p><p>TCP在传输过程中，实际上会有一个缓冲区用于数据的发送和接收：</p><p><img src="/../img/images/j7Ba4IYxQDsVyLq.jpg"></p><p>此缓冲区大小为：8192，我们可以手动调整其大小来优化传输效率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">socket.setReceiveBufferSize(<span class="hljs-number">25565</span>);   <span class="hljs-comment">//TCP接收缓冲区</span><br>socket.setSendBufferSize(<span class="hljs-number">25565</span>);    <span class="hljs-comment">//TCP发送缓冲区</span><br></code></pre></td></tr></table></figure><hr><h3 id="使用Socket传输文件"><a href="#使用Socket传输文件" class="headerlink" title="使用Socket传输文件"></a>使用Socket传输文件</h3><p>既然Socket为我们提供了IO流便于数据传输，那么我们就可以轻松地实现文件传输了。</p><hr><h3 id="使用浏览器访问Socket服务器"><a href="#使用浏览器访问Socket服务器" class="headerlink" title="使用浏览器访问Socket服务器"></a>使用浏览器访问Socket服务器</h3><p>在了解了如何使用Socket传输文件后，我们来看看，浏览器是如何向服务器发起请求的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8088</span>))&#123;    <span class="hljs-comment">//将服务端创建在端口8080上</span><br>            System.out.println(<span class="hljs-string">&quot;正在等待客户端连接...&quot;</span>);<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> server.accept();<br>            System.out.println(<span class="hljs-string">&quot;客户端已连接，IP地址为：&quot;</span>+socket.getInetAddress().getHostAddress());<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> socket.getInputStream();  <br>            System.out.println(<span class="hljs-string">&quot;接收到客户端数据：&quot;</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> in.read();<br>                <span class="hljs-keyword">if</span>(i == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>                System.out.print((<span class="hljs-type">char</span>) i);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们现在打开浏览器，输入<a href="http://xn--localhost:8080http-cr10bp91c//127.0.0.1:8080/，来连接我们本地开放的服务器。">http://localhost:8080或是http://127.0.0.1:8080/，来连接我们本地开放的服务器。</a></p><p>我们发现浏览器是无法打开这个链接的，但是我们服务端却收到了不少的信息：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown">GET / HTTP/1.1<br>Host: localhost:8088<br>Connection: keep-alive<br>sec-ch-ua: &quot;Not.A/Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;114&quot;, &quot;Google Chrome&quot;;v=&quot;114&quot;<br>sec-ch-ua-mobile: ?0<br>sec-ch-ua-platform: &quot;Windows&quot;<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,<span class="hljs-emphasis">*/*</span>;q=0.8,application/signed-exchange;v=b3;q=0.7<br>Sec-Fetch-Site: none<br>Sec-Fetch-Mode: navigate<br>Sec-Fetch-User: ?1<br>Sec-Fetch-Dest: document<br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q=0.9<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oracle学习</title>
    <link href="/2022/09/03/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/09/03/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p><strong>数据库是存放数据的仓库。它的存储空间很大，可以存放百万条、千万条、上亿条数据。但是数据库并不是随意地将数据进行存放，是有一定的规则的，否则查询的效率会很低。</strong></p><span id="more"></span><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="数据库对象"><a href="#数据库对象" class="headerlink" title="数据库对象"></a>数据库对象</h3><ul><li>用户(user)</li><li>表(table)</li><li>视图(view)</li><li>索引(index)</li><li>触发器(trigger)</li><li>存储过程(synonym)</li><li>同义词(synonym)</li><li>序列(sequence)</li></ul><h3 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h3><p>软件开发步骤：</p><ul><li>分析</li><li>设计</li><li>编码</li><li>测试</li><li>部署</li><li>上线</li><li>运维</li></ul><p>数据建模三个阶段：</p><ul><li>概念建模</li><li>逻辑建模</li><li>物理建模</li></ul><h4 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h4><p>三大要素</p><ul><li>实体</li><li>属性</li><li>关系<ul><li>一对一</li><li>一对多</li><li>多对多</li></ul></li></ul><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><blockquote><p>用来唯一表示一行数据</p></blockquote><ul><li>非空唯一</li><li>可以多个列联合在一起做表中的主键</li></ul><h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><blockquote><p>用来表示这个类中的数据，引用另一个表的一个字段值</p></blockquote><ul><li>具有唯一约束的列</li><li>可以为空</li><li>把B表中的联合主键，引用到A表中做外键，这个外键就是一个联合外键（少见）</li></ul><h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><blockquote><p>数据库一般只需要满足第三范式就行了</p></blockquote><h5 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h5><p>一个表中，每个列的值不能再分割</p><h5 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h5><p>在满足第一范式的基础上，表中的非主键列都必须依赖于主键列</p><table><thead><tr><th>订单编号</th><th>订单名称</th><th>订单日期</th><th>产品生产地</th></tr></thead><tbody><tr><td>1</td><td>xxx</td><td>xxx</td><td>xxx</td></tr></tbody></table><blockquote><p>产品生产地不依赖于订单编号，这个列不应该出现在订单表中</p></blockquote><h5 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h5><p>在满足第二范式的基础上，表中的所有非主键列都必须直接依赖于主键列，而不能间接的依赖，就是不能出现依赖传递</p><table><thead><tr><th>订单编号</th><th>订单名称</th><th>顾客编号</th><th>顾客姓名</th></tr></thead><tbody><tr><td>1</td><td>xxx</td><td>xxx</td><td>xxx</td></tr></tbody></table><blockquote><p>顾客编号依赖于订单编号，顾客姓名依赖于顾客编号，顾客姓名间接依赖于订单编号，产生依赖传递，顾客姓名不应该存在</p></blockquote><h5 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h5><h5 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h5><h5 id="第五范式"><a href="#第五范式" class="headerlink" title="第五范式"></a>第五范式</h5><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>一对一关系<ul><li>外键列设置在任意一张表中都可以</li></ul></li><li>一对多关系<ul><li>外键列要设置在多的一方</li></ul></li><li>多对多关系<ul><li>需要设计第三张表（桥表），桥表中设置两个外键，分别引用两个表的主键</li></ul></li></ul><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><ul><li><p>DDL(Data Define Language)数据定义语句</p><ul><li>建立、修改、删除数据库对象<ul><li>CREATE(建立)</li><li>ALTER(修改)</li><li>DROP(删除)</li><li>TRUNCATE(截断)</li></ul></li></ul></li><li><p>DML(Data Manipulation Language)数据操纵语句</p><ul><li>用于改变数据库中的数据<ul><li>INSERT</li><li>UPDATE</li><li>DELETE</li></ul></li></ul></li><li><p>DQL(Data Query Language)数据查询语言</p><ul><li>用于检索数据库中的数据<ul><li>SELECT</li></ul></li></ul></li><li><p>DCL(Data Controller Language)数据控制语言</p><ul><li>用于执行权限授予和权限收回<ul><li>GRANT</li><li>REVOKE</li></ul></li></ul></li><li><p>TCL(Transaction Controller Language)事务控制语言</p><ul><li>用于维护数据一致性<ul><li>COMMIT</li><li>ROLLBACK</li><li>SAVEPOINT</li></ul></li></ul></li></ul><blockquote><p>注意，DML语句需要事务的支持（产生事务），DDL语句会自动提交事务</p></blockquote><h3 id="DDL数据定义语言"><a href="#DDL数据定义语言" class="headerlink" title="DDL数据定义语言"></a>DDL数据定义语言</h3><blockquote><p>Data Define Language</p></blockquote><h4 id="create建表"><a href="#create建表" class="headerlink" title="create建表"></a>create建表</h4><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>[]里的内容可选<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名&#123;<br>字段名 数据类型 [列约束类型],<br>字段名 数据类型 [列约束类型],<br>字段名 数据类型 [列约束类型],<br>字段名 数据类型 [列约束类型],<br>[表级约束],<br>[表级约束]<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><ol><li>必须字母开头</li><li>1-30个字符之间的长度</li><li>字母、数字、_、#</li><li>不能和数据库中已有对象名字重复</li><li>不能是数据库中关键字</li></ol><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><ul><li>char varchar varchar2 都是存储字符串<ul><li>char固定长度 varchar2长度可变</li><li>char效率比varchar2效率高，varchar是数据库标准类型，varchar2是oracle独有</li><li>varchar2不能存空字符串，可以存null</li><li>varchar可以存空字符串</li><li>oracle建议使用varchar2</li></ul></li><li>number(p,s)<ul><li>p表示最大位数(整数位+小数位)，s表示保留的小数位(四舍五入)，也可以为负数</li><li>number(5,2)<ul><li>存进去123.456，取出来位123.46</li><li>存进去12345.456，报错</li><li>整数位最大3位，因为要留两位给小数</li><li>可以直接用number，不加参数默认没限制</li></ul></li></ul></li><li>date<ul><li>日期类型</li></ul></li><li>blob<ul><li>存二进制对象，例如视频，音频，图片</li></ul></li><li>clob<ul><li>存大文本</li></ul></li></ul><h5 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h5><h6 id="列级约束"><a href="#列级约束" class="headerlink" title="列级约束"></a>列级约束</h6><ul><li>主键约束  primary key<ul><li>不可以为null</li></ul></li><li>外键约束 foreign key<ul><li>table1_table2_id number references table2(id)<ul><li>table1_table2_id的值，引用子顾客表table2中主键列id的值<ul><li>删除table1的话就要先删除table2</li><li>或者drop table table1 cascade constraints;</li></ul></li></ul></li></ul></li><li>唯一约束 unique  <ul><li>可以为null</li></ul></li><li>非空约束 not null</li><li>check约束 check(列名 in (‘x’ , ‘y’)) <ul><li>只能在x，y里选值</li><li>也可以为null</li></ul></li></ul><h6 id="表级约束"><a href="#表级约束" class="headerlink" title="表级约束"></a>表级约束</h6><ul><li>和列级约束所写位置不一样</li><li>非空约束不能声明成表级约束</li><li>声明约束位联合主键、联合外键、联合唯一时，一定要用表级约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_order(<br>id number,<br>price number <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>customer_id number,<br>customer_name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>),<br><span class="hljs-keyword">foreign</span> key(customer_id,customer_name) <span class="hljs-keyword">references</span> t_customer(id,name)<br>);<br></code></pre></td></tr></table></figure><h6 id="constraint关键字"><a href="#constraint关键字" class="headerlink" title="constraint关键字"></a>constraint关键字</h6><ul><li>constraint是约束的意思</li><li>可以给约束起名，规律一般是：表名_ 列名 _约束类型</li><li>没给约束起名字，系统也会各一个默认名字</li><li>可以通过起的名字，找到这个约束，进行修改获取操作</li></ul><h6 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>一模一样<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test1<br><span class="hljs-keyword">as</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> s_dept<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>只要表结构，不要数据<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test2<br><span class="hljs-keyword">as</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> s_dept<br><span class="hljs-keyword">where</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>一模一样，只要特定数据<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test3<br><span class="hljs-keyword">as</span> <br><span class="hljs-keyword">select</span> id,last_name,salary<br><span class="hljs-keyword">from</span> s_emp;<br></code></pre></td></tr></table></figure><h6 id="on-delete-xxxx"><a href="#on-delete-xxxx" class="headerlink" title="on delete xxxx"></a>on delete xxxx</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>建表时如果有外键列，在声明外键约束时可加<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表示，在将来删除这个外键列数据的时候，另一张表被引用的数据该如何操作<br><span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">no</span> action <span class="hljs-operator">/</span><span class="hljs-operator">/</span>不做操作<br><span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> cascade  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>级联删除<br><span class="hljs-keyword">on</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">null</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>设置为<span class="hljs-keyword">null</span> <br></code></pre></td></tr></table></figure><h4 id="alter"><a href="#alter" class="headerlink" title="alter"></a>alter</h4><blockquote><p>表建好了，可以用alter修改表信息</p></blockquote><ul><li>在表中添加新列</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_user <br><span class="hljs-keyword">add</span> birthday <span class="hljs-type">date</span>;<br></code></pre></td></tr></table></figure><ul><li>删除表中的列</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_user<br><span class="hljs-keyword">drop</span> colum birthday;<br></code></pre></td></tr></table></figure><ul><li>给表中添加约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_user<br><span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> user_name_un<br><span class="hljs-keyword">unique</span>(name);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>这个约束相当于之前的表级约束<br></code></pre></td></tr></table></figure><ul><li>删除表中约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_user<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">constraint</span> user_name_un;<br></code></pre></td></tr></table></figure><ul><li>修改表名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">rename t_user <span class="hljs-keyword">to</span> mytest;<br></code></pre></td></tr></table></figure><ul><li>修改列的数据类型</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> t_user<br>modify(name varchar2(<span class="hljs-number">500</span>));<br></code></pre></td></tr></table></figure><ul><li>设置约束失效</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">allter <span class="hljs-keyword">table</span> t_usr<br>disable <span class="hljs-keyword">constraint</span> user_id_pk cascade;<br></code></pre></td></tr></table></figure><h4 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> t_user;<br></code></pre></td></tr></table></figure><h4 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> t_user;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>相当于<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> t_user;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><blockquote><p>truncate操作，不用提交，默认以及提交，并且不能回滚</p></blockquote><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>给表添加注释<br>comment <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> t_user <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;很好&#x27;</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>给列加注释<br>comment <span class="hljs-keyword">on</span> <span class="hljs-keyword">column</span> t_user.name <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;good&#x27;</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看表中注释<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_tab_comments <span class="hljs-keyword">where</span> table_name <span class="hljs-operator">=</span> <span class="hljs-built_in">upper</span>(<span class="hljs-string">&#x27;t_user&#x27;</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看列中的注释<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_col_comments<br><span class="hljs-keyword">where</span> <br>comments <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br><span class="hljs-keyword">and</span> <br>table_name <span class="hljs-operator">=</span> <span class="hljs-built_in">upper</span>(<span class="hljs-string">&#x27;t_user&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><blockquote><p>是oracle数据库特有的，其他数据库没有</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> sequence 序列名<br>[INCREMENT <span class="hljs-keyword">BY</span> n]<br>[<span class="hljs-keyword">START</span> <span class="hljs-keyword">WITH</span> n]<br>[&#123;MAXVALUE n <span class="hljs-operator">|</span> NOMAXVALUE&#125;]<br>[&#123;MINVALUE n <span class="hljs-operator">|</span> NOMINVALUE&#125;]<br>[&#123;<span class="hljs-keyword">CYCLE</span> <span class="hljs-operator">|</span> NOCYCLE&#125;]<br>[&#123;CACHE n <span class="hljs-operator">|</span> NOCACHE&#125;]<br><br><span class="hljs-number">1.</span>INCREMENT <span class="hljs-keyword">BY</span> ，用于定义序列的步长，如果省略，则默认为<span class="hljs-number">1</span><br><span class="hljs-number">2.</span> <span class="hljs-keyword">START</span> <span class="hljs-keyword">WITH</span> ， 定义序列的初始值(即产生的第一个值)，默认为<span class="hljs-number">1</span><br><span class="hljs-number">3.</span> MAXVALUE 定义序列能产生的最大值。NOMAXVALUE是默认值，代表没有最大值定义<br><span class="hljs-number">4.</span> MINVALUE 定义序列能产生的最小值。NOMAXVALUE是默认值，代表没有最小值定义<br><span class="hljs-number">5.</span> <span class="hljs-keyword">CYCLE</span> 和 NOCYCLE 表示当序列的值达到限制值后是否循环<br><span class="hljs-number">6.</span> CACHE 定义存放序列值的缓冲区的大小，默认为<span class="hljs-number">20</span>。NOCACHE 表示不对序列进行内存缓冲<br></code></pre></td></tr></table></figure><h3 id="DQL数据查询语言"><a href="#DQL数据查询语言" class="headerlink" title="DQL数据查询语言"></a>DQL数据查询语言</h3><blockquote><p>Data Query Language</p></blockquote><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> [<span class="hljs-keyword">distinct</span>] <span class="hljs-operator">*</span>&#123;column_name1,column_name2&#125; <span class="hljs-keyword">from</span> table_name;<br></code></pre></td></tr></table></figure><h5 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,last_name,salary<span class="hljs-operator">*</span><span class="hljs-number">12</span><br><span class="hljs-keyword">from</span> table_name;<br></code></pre></td></tr></table></figure><h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> column_name [<span class="hljs-keyword">as</span>] new_column_name <span class="hljs-keyword">from</span> table_name;<br></code></pre></td></tr></table></figure><h5 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> column_name1<span class="hljs-operator">||</span><span class="hljs-string">&#x27;kaf&#x27;</span><span class="hljs-operator">||</span>column_name2 <span class="hljs-keyword">from</span> table_name;<br></code></pre></td></tr></table></figure><h5 id="nvl函数"><a href="#nvl函数" class="headerlink" title="nvl函数"></a>nvl函数</h5><p>如果salary为空,显示成0</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,last_name,nvl(salary,<span class="hljs-number">0</span>) salary <span class="hljs-keyword">from</span> table_name;<br></code></pre></td></tr></table></figure><h5 id="去重-distinct"><a href="#去重-distinct" class="headerlink" title="去重(distinct)"></a>去重(distinct)</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> col_name,col_name <span class="hljs-keyword">from</span> table_name;<br></code></pre></td></tr></table></figure><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>排序默认值是asc，表示升序，desc表示降序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col_name,... <span class="hljs-keyword">from</span> table_name <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> col_name[<span class="hljs-keyword">asc</span><span class="hljs-operator">|</span><span class="hljs-keyword">desc</span>];<br></code></pre></td></tr></table></figure><p>多列排序(先按前面的列排序，有重复值再按后面的列排序)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,id2 <br><span class="hljs-keyword">from</span> table_name<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">asc</span>,id2 dsec;<br></code></pre></td></tr></table></figure><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col_name,...<br><span class="hljs-keyword">from</span> table_name<br><span class="hljs-keyword">where</span> colu_name 比较操作表达式 <br></code></pre></td></tr></table></figure><h5 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询salary在<span class="hljs-number">700</span>到<span class="hljs-number">1500</span>之间的id,last_name,salary<br><span class="hljs-keyword">select</span> id,last_name,salary<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-keyword">between</span> <span class="hljs-number">700</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1500</span><br></code></pre></td></tr></table></figure><h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询id为<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>的id,last_name,salary<br><span class="hljs-keyword">select</span> id,last_name,salary<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>);<br></code></pre></td></tr></table></figure><h5 id="like"><a href="#like" class="headerlink" title="like"></a>like</h5><ul><li>%,通配0到多个字符</li><li>_,通过一个字符，并且是一定要有一个字符</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询last_name长度不小于<span class="hljs-number">5</span>，且第四个字母为n字母的id，last_name,salary<br><span class="hljs-keyword">select</span> id,last_name,salary<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> last_name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;___n_%&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>,转义字符,需要用escape关键字指定，转义字符只能转义后面的字符</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询last_name中包含_的id<br><span class="hljs-keyword">select</span> id <br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> last_name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%\_%&#x27;</span> <span class="hljs-keyword">escape</span> <span class="hljs-string">&#x27;\&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="is-null-amp-amp-is-not-null"><a href="#is-null-amp-amp-is-not-null" class="headerlink" title="is null  &amp;&amp; is not null"></a>is null  &amp;&amp; is not null</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询last_name为空的id<br><span class="hljs-keyword">select</span> id<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> last_name <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h5 id="and、or"><a href="#and、or" class="headerlink" title="and、or"></a>and、or</h5><p>and比or优先级要高</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看员工部门为<span class="hljs-number">41</span> 或者 <span class="hljs-number">44</span>号部门，且工资大于<span class="hljs-number">1000</span>的员工id和名字<br><span class="hljs-keyword">select</span> id,last_name,dept_id,title<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">1000</span><br><span class="hljs-keyword">and</span> dept_id <span class="hljs-operator">=</span> <span class="hljs-number">41</span><br><span class="hljs-keyword">or</span> dept_id <span class="hljs-operator">=</span> <span class="hljs-number">44</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查看员工部门为<span class="hljs-number">41</span>且工资大于<span class="hljs-number">1000</span>，或者<span class="hljs-number">44</span>号部门的员工id和名字<br><span class="hljs-keyword">select</span> id,last_name,dept_id,title<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">1000</span><br><span class="hljs-keyword">and</span> <br>(<br>dept_id <span class="hljs-operator">=</span> <span class="hljs-number">41</span><br>    <span class="hljs-keyword">or</span> <br>dept_id <span class="hljs-operator">=</span> <span class="hljs-number">44</span><br>)<br></code></pre></td></tr></table></figure><h4 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h4><h5 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h5><h6 id="ascii-x"><a href="#ascii-x" class="headerlink" title="ascii(x)"></a>ascii(x)</h6><p><strong>返回字符x得ASCII码</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ascii(<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">from</span> dual<br></code></pre></td></tr></table></figure><h6 id="concat-x-y"><a href="#concat-x-y" class="headerlink" title="concat(x,y)"></a>concat(x,y)</h6><p><strong>连接字符串X和Y</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">from</span> dual<br></code></pre></td></tr></table></figure><h6 id="instr-str-n-start"><a href="#instr-str-n-start" class="headerlink" title="instr( str , n, [start] )"></a>instr( str , n, [start] )</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查找o<br><span class="hljs-keyword">select</span> instr&#123;<span class="hljs-string">&#x27;hello world&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>&#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">from</span> dual;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查找o，从下标为<span class="hljs-number">6</span>开始<br><span class="hljs-keyword">select</span> instr&#123;<span class="hljs-string">&#x27;hello world&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-number">6</span>&#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">from</span> dual;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>从后往前查找o,从最后一个开始<br><span class="hljs-keyword">select</span> instr&#123;<span class="hljs-string">&#x27;hello world&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-number">-1</span>&#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><h6 id="length-x"><a href="#length-x" class="headerlink" title="length(x)"></a>length(x)</h6><p><strong>返回x的长度</strong></p><h6 id="upper-amp-amp-lower"><a href="#upper-amp-amp-lower" class="headerlink" title="upper() &amp;&amp; lower()"></a>upper() &amp;&amp; lower()</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-built_in">upper</span>()<span class="hljs-operator">/</span><span class="hljs-operator">/</span>将结果转换成大写<br><span class="hljs-built_in">lower</span>()<span class="hljs-operator">/</span><span class="hljs-operator">/</span>转换成小写<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">upper</span>(last_name) <span class="hljs-keyword">as</span> last_name<br><span class="hljs-keyword">from</span> table_name<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h6 id="initcap-x"><a href="#initcap-x" class="headerlink" title="initcap(x)"></a>initcap(x)</h6><p><strong>将x首字母转换为大写，其他字母小写</strong></p><h6 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-built_in">trim</span>(trim_str <span class="hljs-keyword">from</span> x),把x的两边截去trim_str字符串，不能有空格<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27;=&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;=hello=&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">from</span> dual;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>ltrim(x,trim_str),把x的左边截去trim_str字符串，不能有空格<br><span class="hljs-keyword">select</span> ltrim(<span class="hljs-string">&#x27;=hello=&#x27;</span>,<span class="hljs-string">&#x27;=&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">from</span> dual;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>rtrim同理，截右边<br></code></pre></td></tr></table></figure><h6 id="substr-x-start-length"><a href="#substr-x-start-length" class="headerlink" title="substr(x,start,length)"></a>substr(x,start,length)</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">从<span class="hljs-keyword">start</span>开始，截取length个字符<br><span class="hljs-keyword">select</span> substr(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><h5 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h5><h6 id="abs-x"><a href="#abs-x" class="headerlink" title="abs(x)"></a>abs(x)</h6><p><strong>x的绝对值</strong></p><h6 id="acos-x-amp-amp-asin-x"><a href="#acos-x-amp-amp-asin-x" class="headerlink" title="acos(x) &amp;&amp; asin(x)"></a>acos(x) &amp;&amp; asin(x)</h6><p><strong>x的反余弦    x的反正弦</strong></p><h6 id="cos-x-amp-amp-sin-x"><a href="#cos-x-amp-amp-sin-x" class="headerlink" title="cos(x) &amp;&amp; sin(x)"></a>cos(x) &amp;&amp; sin(x)</h6><p><strong>余弦   正弦</strong> </p><h6 id="ceil-x-amp-amp-floor-x"><a href="#ceil-x-amp-amp-floor-x" class="headerlink" title="ceil(x) &amp;&amp; floor(x)"></a>ceil(x) &amp;&amp; floor(x)</h6><p><strong>大于或等于x的最小值(整数)   小于或等于x的最大值(整数)</strong></p><h6 id="log-x-y-amp-amp-mod-x-y-amp-amp-power-x-y"><a href="#log-x-y-amp-amp-mod-x-y-amp-amp-power-x-y" class="headerlink" title="log(x,y) &amp;&amp; mod(x,y) &amp;&amp; power(x,y)"></a>log(x,y) &amp;&amp; mod(x,y) &amp;&amp; power(x,y)</h6><p><strong>x为底y的对数x除以y的余数 x的y次方</strong></p><h6 id="round-x-y"><a href="#round-x-y" class="headerlink" title="round(x,y)"></a>round(x,y)</h6><p><strong>x在第y位四舍五入</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">round(<span class="hljs-number">3.456</span>,<span class="hljs-number">2</span>)<span class="hljs-operator">=</span><span class="hljs-number">3.46</span><br></code></pre></td></tr></table></figure><h6 id="sqrt-x"><a href="#sqrt-x" class="headerlink" title="sqrt(x)"></a>sqrt(x)</h6><p><strong>x的平方根</strong></p><h6 id="trunc-x-y"><a href="#trunc-x-y" class="headerlink" title="trunc(x,y)"></a>trunc(x,y)</h6><p><strong>x在第y位截断</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">trunc(<span class="hljs-number">3.456</span>,<span class="hljs-number">2</span>)<span class="hljs-operator">=</span><span class="hljs-number">3.45</span><br></code></pre></td></tr></table></figure><h5 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h5><h6 id="sysdate"><a href="#sysdate" class="headerlink" title="sysdate"></a>sysdate</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>显示当前时间<br><span class="hljs-keyword">select</span> sysdate <span class="hljs-keyword">from</span> dual<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>显示时间:明天这个时候<br><span class="hljs-keyword">select</span> sysdate <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> dual<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>显示时间:<span class="hljs-number">1</span>个小时后<br><span class="hljs-keyword">select</span> sysdaye <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">24</span> <span class="hljs-keyword">from</span> dual<br></code></pre></td></tr></table></figure><h6 id="months-between"><a href="#months-between" class="headerlink" title="months_between"></a>months_between</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">30</span>天以后和现在差多少个月<br><span class="hljs-keyword">select</span> months_between(sysdate<span class="hljs-operator">+</span><span class="hljs-number">30</span>,sysdate) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br></code></pre></td></tr></table></figure><h6 id="add-months"><a href="#add-months" class="headerlink" title="add_months"></a>add_months</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>指定日期往后推<span class="hljs-number">2</span>个月<br><span class="hljs-keyword">select</span> add_months(<span class="hljs-string">&#x27;01-10月-2020&#x27;</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br></code></pre></td></tr></table></figure><h6 id="next-day"><a href="#next-day" class="headerlink" title="next_day"></a>next_day</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>离当前时间最近的星期五是那一天<br><span class="hljs-keyword">select</span> next_day(sysdate,<span class="hljs-string">&#x27;星期五&#x27;</span>);<br></code></pre></td></tr></table></figure><h6 id="last-date"><a href="#last-date" class="headerlink" title="last_date"></a>last_date</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>当前日期所在月份的最后一天<br><span class="hljs-keyword">select</span> last_day(sysdate) <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><h6 id="round"><a href="#round" class="headerlink" title="round"></a>round</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>把当前日期四舍五入到年<br><span class="hljs-keyword">select</span> round(sysdate,<span class="hljs-string">&#x27;YEAR&#x27;</span>) <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><h6 id="trunc"><a href="#trunc" class="headerlink" title="trunc"></a>trunc</h6><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">对日期进行截取<br></code></pre></td></tr></table></figure><h4 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h4><h5 id="tochar"><a href="#tochar" class="headerlink" title="tochar"></a>tochar</h5><h6 id="数字转字符"><a href="#数字转字符" class="headerlink" title="数字转字符"></a>数字转字符</h6><table><thead><tr><th><strong>参数</strong></th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>9</td><td>999</td><td>指定位置处显示数字</td></tr><tr><td>.</td><td>9.9</td><td>指定位置返回小数点</td></tr><tr><td>，</td><td>99，99</td><td>指定位置返回一个逗号</td></tr><tr><td>$</td><td>$999</td><td>数字开头返回一个美元符号</td></tr><tr><td>L</td><td>L999</td><td>数字开头返回一个本地的货币符号</td></tr><tr><td>PR</td><td>999PR</td><td>如果数字是负数用尖括号进行表示</td></tr></tbody></table><h6 id="日期转字符"><a href="#日期转字符" class="headerlink" title="日期转字符"></a>日期转字符</h6><table><thead><tr><th><strong>格式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>yyyy</td><td>四位数的年份</td></tr><tr><td>rrrr</td><td>四位数的年份</td></tr><tr><td>yy</td><td>两位数的年份</td></tr><tr><td>rr</td><td>两位数的年份</td></tr><tr><td>mm</td><td>两位数的月份（数字）</td></tr><tr><td>D</td><td>一周的星期几</td></tr><tr><td>DD</td><td>一月的第几天</td></tr><tr><td>DDD</td><td>一年的第几天</td></tr><tr><td>YEAR</td><td>英文的年份</td></tr><tr><td>MONTH</td><td>英文全称的月份</td></tr><tr><td>mon</td><td>英文简写的月份</td></tr><tr><td>ddsp</td><td>英文的第几天(一个月的)</td></tr><tr><td>ddspth</td><td>英文序列数的第几天(一个月的)</td></tr><tr><td>DAY</td><td>全英文的星期</td></tr><tr><td>DY</td><td>简写的英文星期</td></tr><tr><td>hh</td><td>小时</td></tr><tr><td>mi</td><td>分钟</td></tr><tr><td>ss</td><td>秒</td></tr></tbody></table><h5 id="to-number"><a href="#to-number" class="headerlink" title="to_number"></a>to_number</h5><h5 id="to-date"><a href="#to-date" class="headerlink" title="to_date"></a>to_date</h5><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><ul><li><p>等值连接</p></li><li><p>不等值连接</p></li><li><p>外连接</p><ul><li>左外连接</li><li>右外连接</li><li>全连接</li></ul></li><li><p>自连接</p></li></ul><h5 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h5><blockquote><p>利用一张表中某列的值，和另一张表中某列的值相等的关系，把两张表连接起来</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> table1.col1,col2, table2.col1,col2<br><span class="hljs-keyword">from</span> table1,table2<br><span class="hljs-keyword">where</span> table1.col1 <span class="hljs-operator">=</span> table2.col1;<br></code></pre></td></tr></table></figure><h5 id="不等值连接"><a href="#不等值连接" class="headerlink" title="不等值连接"></a>不等值连接</h5><p>假设数据库中有一张工资等级表，salgrade</p><ul><li>gradeName 表示等级名称</li><li>losal 表示这个级别的最低工资数</li><li>hisal表示这个级别的最高工资数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询员工名字，职位，工资，工资等级<br><span class="hljs-keyword">select</span> e.last_name,e.title,e.salary,s.gradeName<br><span class="hljs-keyword">from</span> s_emp e , salgrade s <br><span class="hljs-keyword">where</span> e.salary <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal;<br></code></pre></td></tr></table></figure><h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><blockquote><p>员工不在任何部门中 或者 部门下没有任何员工</p><p>这种情况等值连接查不到</p></blockquote><h6 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询所有员工，以及对应的部门的名字，没有部门的员工也要显示出来<br><span class="hljs-keyword">select</span> last_anme,dept_id,name<br><span class="hljs-keyword">from</span> s_emp <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> s_dept<br><span class="hljs-keyword">on</span> s_emp.dept_id <span class="hljs-operator">=</span> s_dept.id;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>oracle简写<br><span class="hljs-keyword">select</span> last_name,dept_id,name<br><span class="hljs-keyword">from</span> s_emp,s_dept<br><span class="hljs-keyword">where</span> s_emp.dept_id<span class="hljs-operator">=</span>s_dept.id(<span class="hljs-operator">+</span>);<br></code></pre></td></tr></table></figure><h6 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询所有员工以及对应部门的名字，没有员工的部门也要显示出来<br><span class="hljs-keyword">select</span> last_name,dept_id,name<br><span class="hljs-keyword">from</span> s_emp <span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> s_dept<br><span class="hljs-keyword">on</span> s_emp.dept_id <span class="hljs-operator">=</span> s_dept.id;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>oracle简写<br><span class="hljs-keyword">select</span> last_name,dept_id,name<br><span class="hljs-keyword">from</span> s_emp,s_dept<br><span class="hljs-keyword">where</span> s_emp.dept_id(<span class="hljs-operator">+</span>)<span class="hljs-operator">=</span>s_dept.id;<br></code></pre></td></tr></table></figure><h6 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询所有员工以及对应部门名字，没有员工的部门也要显示出来，没有部门的员工也要显示出来<br><span class="hljs-keyword">select</span> last_name,dept_id,name<br><span class="hljs-keyword">from</span> s_emp <span class="hljs-keyword">full</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> s_dept<br><span class="hljs-keyword">on</span> s_emp.dept_id <span class="hljs-operator">=</span> s_dept.id;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>全连接 oracle没有简写<br></code></pre></td></tr></table></figure><h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><blockquote><p>一张表，自己和自己连接后查询</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询每个员工名字以及员工对应管理者的名字<br><span class="hljs-keyword">select</span> s1.last_anme,s2.last_name manager_name<br><span class="hljs-keyword">from</span> s_emp s1,s_emp s2<br><span class="hljs-keyword">where</span> s1.manager_id <span class="hljs-operator">=</span> s2.id;<br></code></pre></td></tr></table></figure><hr><h5 id="操作结果集"><a href="#操作结果集" class="headerlink" title="操作结果集"></a>操作结果集</h5><blockquote><p><strong>每条sql语句</strong>查询出来的<strong>结果</strong>都可以被称为<strong>结果集</strong></p></blockquote><ul><li>union     取两个结果集的并集</li><li>union all      把两个结果集合在一起显示</li><li>minus          第一个结果集除去第二结果集和它相同的部分</li><li>intersect      求两个结果集的交集</li></ul><p> </p><hr><h5 id="rownum-Oracle才有"><a href="#rownum-Oracle才有" class="headerlink" title="rownum(Oracle才有)"></a>rownum(Oracle才有)</h5><blockquote><p>rownum如果是相同的条件，只能等于1</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> last_name <br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> rownum <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><blockquote><p>rownum如果是大于的条件，只能大于0</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> last_name <br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> rownum <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><blockquote><p>rownum可以小于任何数</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> last_name<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> rownum <span class="hljs-operator">&lt;</span> <span class="hljs-number">7</span>;<br></code></pre></td></tr></table></figure><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><ul><li>group by()分组函数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> dept_id,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>),<span class="hljs-built_in">sum</span>(salary)<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id<br>orader <span class="hljs-keyword">by</span> dept_id<br></code></pre></td></tr></table></figure><ul><li>avg  求平均值</li><li>count  计算有多少条数据</li><li>max     求最大值</li><li>min      求最小值</li><li>sum     求和</li></ul><h5 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段<span class="hljs-number">1</span>，字段<span class="hljs-number">2</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>聚合函数可以出现<br><span class="hljs-keyword">from</span> 表<br><span class="hljs-keyword">where</span> 条件<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组条件<br><span class="hljs-keyword">having</span> 分组筛选条件  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>聚合函数可以出现<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序顺序<span class="hljs-operator">/</span><span class="hljs-operator">/</span>聚合函数可以出现<br></code></pre></td></tr></table></figure><h6 id="where和having："><a href="#where和having：" class="headerlink" title="where和having："></a>where和having：</h6><ol><li>where 和 having 都是做条件筛选</li><li>where 执行时间比 having 早</li><li>where 后面不能出现组函数</li><li>having 后面可以出现组函数</li><li>where 语句要紧跟 from</li><li>having 要紧跟 group by</li></ol><h6 id="group-by-和-having："><a href="#group-by-和-having：" class="headerlink" title="group by 和 having："></a>group by 和 having：</h6><ol><li>group by 后面可以不接 having</li><li>having 必须跟在 group by 后面</li></ol><h6 id="order-by："><a href="#order-by：" class="headerlink" title="order by："></a>order by：</h6><ol><li>如果sql语句需要排序，一定写在sql语句最后</li><li>order by 后面可以出现组函数</li></ol><h6 id="默认分组"><a href="#默认分组" class="headerlink" title="默认分组"></a>默认分组</h6><ul><li>如果使用了group by分组，那就表示先分组，然后对每一个小组使用聚合函数</li><li>如果没有使用group by，表示全部数据是一个默认小组，然后对这个全部数据使用聚合函数</li></ul><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><blockquote><p>就是嵌套查询，select语句中嵌套另一个或多个select语句</p></blockquote><h3 id="DML数据操纵语言"><a href="#DML数据操纵语言" class="headerlink" title="DML数据操纵语言"></a>DML数据操纵语言</h3><blockquote><p>Data Manipulationg Language</p></blockquote><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;xxxxx&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;11-8月98&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>违反任意一种约束就插入数据失败</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user(id,name,eamail,gender,age,birthday)<br><span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;xxxxx&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;11-8月98&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> 列名<span class="hljs-number">1</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">1</span>,列名<span class="hljs-number">2</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">2</span> , .... <span class="hljs-keyword">where</span> 条件; <br></code></pre></td></tr></table></figure><blockquote><p>不带条件，就将表中所有数据更新</p></blockquote><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 条件;<br></code></pre></td></tr></table></figure><blockquote><p>不加条件，就把表中所有数据删除</p></blockquote><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p>事务Transaction,是由一系列对数据库表中数据，进行访问和更新的操作，所组成的一个执行逻辑单元</p></blockquote><ul><li>只有DML语句才会产生事务</li><li>DML语句执行时，如果当前有事务，就使用这个事务，如果没有，就产生</li><li>commit、rollback、DDL语句都可以把当前事务结束掉</li><li>commit和DDL语句结束事务的方式就是把这个事务给提交了，DML操作永久生效</li><li>rollback结束事务的方式是回滚，回到事务开始 的状态</li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p><strong>事务特征（ACID）：</strong></p><ul><li>原子性：Atomicity<ul><li>一个事务中所有的DML语句，同时成功同时失败</li></ul></li><li>一致性：Consistency<ul><li>事务执行的结果必须是使数据库从一个一致性状态变成另一个一致性状态</li></ul></li><li>隔离性：Isolation<ul><li>事务操作应该相互独立</li></ul></li><li>持久性：Durability<ul><li>事务所作的影响，在事务结束后应该能够是持久的</li></ul></li></ul><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> ....产生事务A<br><span class="hljs-keyword">update</span> ... 这个操作是事务A中的操作<br><span class="hljs-keyword">insert</span> .. 这个操作是事务A中的操作<br><span class="hljs-keyword">commit</span>; 让事务A里面的三个操作生效、事务A结束<br><span class="hljs-keyword">delete</span> ... 产生新的事务B<br><span class="hljs-keyword">insert</span> .. 这个操作是事务B中的操作<br><span class="hljs-keyword">insert</span> .. 这个操作是事务B中的操作<br><span class="hljs-keyword">insert</span> .. 这个操作是事务B中的操作<br><span class="hljs-keyword">rollback</span>; 让事务B中的四个操作都撤销,事务B结束<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> ....产生事务A<br><span class="hljs-keyword">update</span> ... 这个操作是事务A中的操作<br><span class="hljs-keyword">insert</span> .. 这个操作是事务A中的操作<br>DDL语句; 事务A会被提交,事务A结束<br><span class="hljs-keyword">rollback</span>; 这时候回滚已经对事务A不起作用,因为事务A以及被提交了,当前已经没有事务了<br></code></pre></td></tr></table></figure><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><blockquote><p>进行事务回滚时，默认回滚到事务开始时的状态</p></blockquote><p><strong>设置回滚点</strong></p><p><strong>savepoint</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">DML<br><span class="hljs-keyword">savepoint</span> A<br>DML<br><span class="hljs-keyword">savepoint</span> B<br>DML<br><span class="hljs-keyword">rollback</span> <span class="hljs-keyword">to</span> A<span class="hljs-operator">/</span>B<br></code></pre></td></tr></table></figure><blockquote><p><strong>rollback</strong>到回滚点后，这个事务没有结束，可以接着回滚或者commit提交</p></blockquote><h3 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h3><blockquote><p>在数据库中，使用事务隔离级别，来解决事务在并发访问中，产生的一些问题</p></blockquote><ul><li>脏读<ul><li>主要针对update操作，一个事务读到另一个事务中修改过但是没有提交的数据</li></ul></li><li>不可重复读<ul><li>主要针对update操作，一个事务在第一次读数据和第二次读数据之间，有另一个事务把这个数据更改并提交了，所以出现读一个数据两次，但是读到结果不同的情况</li></ul></li><li>幻读<ul><li>主要针对insert&#x2F;delete操作，事务A第一次用where条件筛选出10条数据，事务A第二次用同样的where条件筛选出却是11条数据，因为事务B在事务A的第一次和第二次查询之间进行了插入操作，并且插入的这个数据满足事务A的where筛选条件</li></ul></li></ul><p><strong>事务隔离级别</strong></p><ul><li>read-uncommitted  不提交也能读</li><li>read-committed  提交后才能读，解决了脏读</li><li>repeatable-read  解决了脏读和不可重复读</li><li>serializable      三个问题都解决</li></ul><blockquote><p>级别越高解决问题越多但是效率越低</p><p>Oracle只支持第二、第四种</p><p>Mysql四种都支持</p></blockquote><p>设置事务隔离级别的sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Set</span> Transaction Isolation Level Read Uncommitted<br><span class="hljs-keyword">Set</span> Transaction Isolation Level Read Committed<br><span class="hljs-keyword">Set</span> Transaction Isolation Level Read Repeatable<br><span class="hljs-keyword">Set</span> Transaction Isolation Level Serializable<br></code></pre></td></tr></table></figure><blockquote><p>Oracle里默认第二种</p></blockquote><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li>类似书的目录结构</li><li>Oracle的索引是一种对象，是与表关联的可选对象，能提高SQL查询速度</li><li>索引直接指向包含所查询值得行得位置，减少磁盘I&#x2F;O</li><li>索引和表是相互独立得物理结构</li><li>Oracle自动使用并维护索引，插入、删除、更新表后，自动更新索引</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>关系型数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树遍历</title>
    <link href="/2022/08/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <url>/2022/08/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p><strong>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要</strong></p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeSet</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>        String node;<br>        Node leftNode;<br>        Node rightNode;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(String node,Node leftNode,Node rightNode)</span>&#123;<br>            <span class="hljs-built_in">this</span>.node = node;<br>            <span class="hljs-built_in">this</span>.leftNode = leftNode;<br>            <span class="hljs-built_in">this</span>.rightNode = rightNode;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNode</span><span class="hljs-params">(String node)</span> &#123;<br>            <span class="hljs-built_in">this</span>.node = node;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLeftNode</span><span class="hljs-params">(Node leftNode)</span> &#123;<br>            <span class="hljs-built_in">this</span>.leftNode = leftNode;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRightNode</span><span class="hljs-params">(Node rightNode)</span> &#123;<br>            <span class="hljs-built_in">this</span>.rightNode = rightNode;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getLeftNode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> leftNode;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getRightNode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> rightNode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">D</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">E</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">F</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">G</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-string">&quot;G&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-string">&quot;B&quot;</span>,D,E);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">C</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-string">&quot;C&quot;</span>,F,G);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-string">&quot;A&quot;</span>,B,C);<br>        preorder(A);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//先序遍历 中 左 右</span><br>        <span class="hljs-comment">//中序遍历 左 中 右</span><br>        <span class="hljs-comment">//后序遍历 左 右 中</span><br>        preorder(node.leftNode);<br>        preorder(node.rightNode);<br>        System.out.print(node.getNode()+<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例设计模式</title>
    <link href="/2022/08/08/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/08/08/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><ol><li><p>类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p><span id="more"></span></li><li><p>单例模式有两种方式</p><ol><li>饿汉式</li><li>懒汉式</li></ol></li></ol><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>构造器私有化</li><li>类内部创建对象</li><li>向外暴露一个静态的公用方法 getInstance()</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="饿汉式（无论是否使用都创建）"><a href="#饿汉式（无论是否使用都创建）" class="headerlink" title="饿汉式（无论是否使用都创建）"></a>饿汉式（无论是否使用都创建）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleTon01</span>&#123;<br>    <br>    <span class="hljs-comment">//为了能够在静态方法中，返回gf对象，需要将其修饰为static</span><br>    <span class="hljs-comment">//2.在类的内部直接创建</span><br>    <span class="hljs-comment">//对象，通常是重量级对象，饿汉式可能创建了对象但是没有使用，造成资源浪费</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingleTon01</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleTon01</span>();<br>    <br>    <span class="hljs-comment">//1.构造器私有化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleTon01</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">//必须为静态方法，通过类.方法的方式调用，非静态方法需创建对象</span><br>    <span class="hljs-comment">//3.提供一个公共的static方法，返回对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon01 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="懒汉式（只有使用时才创建）"><a href="#懒汉式（只有使用时才创建）" class="headerlink" title="懒汉式（只有使用时才创建）"></a>懒汉式（只有使用时才创建）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleTon02</span>&#123;<br>        <br>    <br>    <span class="hljs-comment">//2.定义一个static静态属性对象</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleTon02 instance<br>    <br>    <span class="hljs-comment">//1.仍然构造器私有化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleTon02</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">//必须为静态方法，通过类.方法的方式调用，非静态方法需创建对象</span><br>    <span class="hljs-comment">//3.提供一个公共的static方法，返回对象</span><br>    <span class="hljs-comment">//4.懒汉式，只有当用户使用getInstance时，才返回对象，后面调用会返回上次创建的对象</span><br>    <span class="hljs-comment">//从而保证单例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon02 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//为空时创建对象</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleTon02</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>创建对象时机不同<ul><li>饿汉式：类加载时创建对象实例</li><li>懒汉式：使用时创建</li></ul></li><li>线程安全：<ul><li>饿汉式：不存在线程安全问题</li><li>懒汉式：存在</li></ul></li><li>资源浪费问题<ul><li>饿汉式：存在浪费资源的可能</li><li>懒汉式：不存在</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java反射</title>
    <link href="/2022/08/07/Java%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/08/07/Java%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p><strong>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意方法和属性，并且能改变它的属性</strong></p><span id="more"></span><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><h3 id="Class类型"><a href="#Class类型" class="headerlink" title="Class类型"></a>Class类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基本类型</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-type">int</span>.class;<br><span class="hljs-comment">//引用类型</span><br>Class&lt;Stduent&gt; c = Student.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">Class</span>&lt;Stduent[]&gt; c = Student[].class<br></code></pre></td></tr></table></figure><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.通过类.class</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-type">int</span>.class;<br><br><span class="hljs-comment">//2.通过对象.class</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.getClass();<br><span class="hljs-comment">//多态 Student s = new 子类();</span><br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Student</span>&gt; c = s.getClass();<br><span class="hljs-type">Action</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Action</span>()&#123;  <br>&#125;;<br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Student</span>&gt; c = s.getClass();<br><br><span class="hljs-comment">//3.Class.forName() 最常用 加载并初始化</span><br>Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;com.kaf.reflect.testclass.Student&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="获取类信息"><a href="#获取类信息" class="headerlink" title="获取类信息"></a>获取类信息</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClassSelf</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//1.获取Class对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">//2.获取运行时字节码信息</span><br>        <span class="hljs-comment">//类的名字</span><br>        System.out.println(c.getName());<br>        <span class="hljs-comment">//Student</span><br>        System.out.println(c.getSimpleName());<br>        <span class="hljs-comment">//类所在包</span><br>        System.out.println(c.getPackage());<br>        <span class="hljs-comment">//类修饰符</span><br>        System.out.println()<br>        <span class="hljs-comment">//一个父类 java.lang.Object</span><br>        System.out.println(c.getSuperClass());<br>        <span class="hljs-comment">//接口数组 interface </span><br>        System.out.println(Arrays.toString(c.getInterfaces));<br>        <span class="hljs-comment">//是否为原始类型</span><br>        System.out.println(c.isPrimitive());<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-type">int</span>.class;<span class="hljs-comment">// true</span><br>        System.out.println(c2.isPrimitive());<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Integer.class;<br>        System.out.println(c3.isPrimitive());<br>        <span class="hljs-comment">//c是否为Action.class的父类</span><br>        System.out.println(c.isAssiginableFrom(Action.class));<br>    &#125;<br>&#125;<br><br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Action</span>,Mark&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> num;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello! &quot;</span>+name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">star</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Action</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Mark</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">star</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="类属性、方法、构造器"><a href="#类属性、方法、构造器" class="headerlink" title="类属性、方法、构造器"></a>类属性、方法、构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClassInfo</span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Student.class;<br>        <span class="hljs-comment">//字段 Field</span><br>        getFields(c);<br>        <br>        <span class="hljs-comment">//方法</span><br>        getMethods(c);<br>        <br>        <span class="hljs-comment">//构造器</span><br>        getConstructor(c);<span class="hljs-comment">//TODO</span><br>        <br>        <span class="hljs-comment">//注解</span><br>        getAnnotations(c);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getFields</span><span class="hljs-params">(Class c)</span>&#123;<br>        <span class="hljs-comment">//获取所有公有字段，包括父类字段；</span><br>        Field[] fields = c.getFields();<br>        <span class="hljs-keyword">for</span>(Field : fields)&#123;<br>            <span class="hljs-comment">//public static in a;</span><br>            System.out.println(<span class="hljs-string">&quot;变量名:&quot;</span> + field.getName());<br>            Syetem.out.println(<span class="hljs-string">&quot;参数类型:&quot;</span> + field.getType().getName());<br>            System.out.println(<span class="hljs-string">&quot;修饰符:&quot;</span> + Modifier.toString(field.getModifiers()));<br>        &#125;<br>        <span class="hljs-comment">//获取所有声明的字段 包括私有 不能获取父类的字段</span><br>        <span class="hljs-comment">//Field[] getDeclaredFields()</span><br><span class="hljs-comment">//Field getDeclaredField(String name)</span><br><br>    &#125;<br>    <br>    <br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMethods</span><span class="hljs-params">(Class c)</span>&#123;<br>        Method[] methods = c.getMethods();<br>        <span class="hljs-comment">//public String getNum(String name,int id)) throws Exception&#123;&#125;</span><br>        <span class="hljs-keyword">for</span> (Method method : method)&#123;<br>            System.out.println(<span class="hljs-string">&quot;名称&quot;</span> + method.getName());<br>            System.out.println(<span class="hljs-string">&quot;返回类型&quot;</span> + method.getReturnTyepe().getName());<br>            System.out.println(<span class="hljs-string">&quot;修饰符&quot;</span> + Modifier.toString(method.getMOdifiers()));<br>            System.out.println(<span class="hljs-string">&quot;参数类型&quot;</span> + Arrays.toString(method.getParameterTyepes()));<br>            System.out.println(<span class="hljs-string">&quot;参数个数&quot;</span> + method.getParameterCount());<br>            <br>        &#125;<br>    &#125;<br>    <br>    <br>    <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Action</span>,Mark&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> num;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello! &quot;</span>+name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">star</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Action</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Mark</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">star</span><span class="hljs-params">()</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>coreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coreJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
